Shell 编程是 Linux/UNIX 环境下必备的技能，核心是通过脚本自动化执行命令、处理文本、管理系统。本文基于 **Bash（Bourne-Again Shell）**（Linux 默认 Shell）编写

# 一、基础入门：Shell 脚本核心概念
## 1.1 编程介绍
### 1.1.1 编程语言初始
#### 1.1.1.1 基础知识
##### 1.1.1.1.1 核心知识点

1. **编程的本质**：
    
    编程是将人类解决问题的逻辑，转化为计算机能理解并执行的**指令集合**。计算机只能识别二进制（0/1），编程语言作为 “翻译器”，让人类用接近自然语言的方式编写指令，再通过解释器 / 编译器转化为机器码。
2. **Shell 编程的定位**：
    
    Shell 编程是面向 **Linux/UNIX 系统管理、自动化操作** 的脚本编程，核心价值是 “串联系统命令”—— 无需编写复杂逻辑，即可快速实现文件处理、进程管理、批量任务自动化。
3. **计算机执行程序的基本逻辑**：
    - 输入：接收用户 / 文件 / 其他程序的指令 / 数据；
    - 处理：CPU 执行指令（计算、判断、循环等）；
    - 输出：返回结果（屏幕打印、文件写入、状态码等）；
        
        Shell 脚本完全遵循此逻辑，比如 `ls -l` 是 “输入指令”，CPU 执行文件遍历逻辑，最终在终端输出文件列表。
4. **Shell 与操作系统的关系**：
    
    Shell 是用户与操作系统内核（Kernel）之间的 “中间层”：用户编写 Shell 脚本 → Shell 解释器（如 Bash）解析指令 → 调用内核接口执行（如读写文件、创建进程）→ 返回结果给用户。

##### 1.1.1.1.2 配套示例（理解执行逻辑）

```bash
#!/bin/bash
# 演示 Shell 脚本的“输入-处理-输出”逻辑
# 输入：定义变量接收用户输入
read -p "请输入一个数字：" num

# 处理：判断数字奇偶性
if (( num % 2 == 0 )); then
    result="偶数"
else
    result="奇数"
fi

# 输出：打印处理结果
echo "你输入的数字 $num 是 $result"
```
#### 1.1.1.2 编程语言
##### 1.1.1.2.1 核心知识点

1. **编程语言的本质**：
    
    是一套 “语法规则 + 语义定义” 的集合，用于描述 “计算机该做什么、怎么做”。不同编程语言的核心差异在于**设计目标**（如 C 追求效率、Python 追求简洁、Shell 追求系统命令联动）。
2. **Shell 语言的核心特点**：

|特点|说明|
|---|---|
|解释型|无需编译，由 Bash 逐行解析执行（对比 C 编译型语言）|
|弱类型|无需声明变量类型（如 `a=10` 是数值，`a="abc"` 是字符串）|
|命令导向|核心是调用 Linux 系统命令（ls、grep、sed 等），而非原生语法|
|轻量高效|适合短脚本、自动化任务，不适合复杂业务逻辑（如大型应用开发）|

    
3. **Shell 与其他主流语言的对比**

| 语言     | 类型         | 适用场景        | 对比 Shell                    |
| ------ | ---------- | ----------- | --------------------------- |
| C      | 编译型 / 低级语言 | 操作系统、底层组件   | 效率极高，但开发复杂；Shell 依赖 C 编写的内核 |
| Python | 解释型 / 高级语言 | 数据分析、Web 开发 | 语法更优雅，生态更全；Shell 处理系统命令更直接  |
| Java   | 编译 + 解释型   | 大型应用、企业级开发  | 跨平台性强；Shell 无跨平台优势（仅适配 U    |
    
4. **Shell 的版本与选型**：
    - 基础 Shell（sh）：UNIX 原生 Shell，语法简单但功能少；
    - Bash（Bourne-Again Shell）：Linux 默认 Shell，兼容 sh，扩展了变量、循环、函数等功能（本文核心）；
    - Zsh/Fish：增强型 Shell，交互更友好（如自动补全），但脚本兼容性不如 Bash。

##### 1.1.1.2.2 配套示例（Shell 与 Python 实现相同逻辑）

```bash
# Shell 版本：计算1-10的和
#!/bin/bash
sum=0
for ((i=1; i<=10; i++)); do
    sum=$((sum + i))
done
echo "Shell计算1-10的和：$sum"
```

```python
# Python 版本：计算1-10的和（对比参考）
sum = 0
for i in range(1, 11):
    sum += i
print(f"Python计算1-10的和：{sum}")
```

#### 1.1.1.3 编程语言类型
##### 1.1.1.3.1 核心知识点

编程语言可按 **执行方式、抽象层次、用途** 分为不同类型，Shell 属于 “解释型、高级脚本语言、系统级语言”，以下是核心分类及 Shell 的定位：

###### 1.1.1.3.1.1 按执行方式分类（最核心）

|类型|定义|执行流程|代表语言|Shell 归属|
|---|---|---|---|---|
|编译型|编写完成后需通过编译器转化为机器码（二进制文件），运行时直接执行机器码|源码 → 编译 → 可执行文件 → 运行|C、C++、Go|❌ 不属于|
|解释型|无需编译，由解释器逐行解析源码并执行|源码 → 解释器逐行执行|Shell、Python、JavaScript|✅ 典型解释型|

**关键差异**：

- 编译型：一次编译，多次运行（效率高，如 `gcc test.c -o test` 生成可执行文件 `test`）；
- 解释型：每次运行都需解释器（灵活，修改源码后直接运行，无需重新编译）。

###### 1.1.1.3.1.2 按抽象层次分类

|类型|定义|特点|代表语言|Shell 归属|
|---|---|---|---|---|
|低级语言|贴近机器码，直接操作硬件|效率极高，语法晦涩|机器语言、汇编语言|❌ 不属于|
|高级语言|贴近人类自然语言，屏蔽硬件细节|易读易写，开发效率高|Shell、Python、Java|✅ 高级语言|

###### 1.1.1.3.1.3 按用途分类

|类型|定义|代表语言|Shell 归属|
|---|---|---|---|
|系统级语言|面向操作系统管理、硬件交互|C、Shell|✅ 核心用途是系统管理|
|应用级语言|面向业务开发（Web、APP、数据分析）|Python、Java、JavaScript|❌ 不适合复杂应用开发|
|脚本语言|面向自动化任务、批量处理|Shell、Perl、Python|✅ 典型脚本语言|

##### 1.1.1.3.2 配套示例（编译型 vs 解释型 对比演示）

###### 步骤 1：编译型语言（C）示例

```c
// test.c（C语言源码）
#include <stdio.h>
int main() {
    int sum = 0;
    for (int i=1; i<=10; i++) {
        sum += i;
    }
    printf("C语言计算1-10的和：%d\n", sum);
    return 0;
}
```


```bash
# 1. 编译：将C源码转化为可执行文件
gcc test.c -o test

# 2. 运行可执行文件（无需编译器，直接执行）
./test

# 3. 再次运行（无需重新编译）
./test
```

###### 步骤 2：解释型语言（Shell）示例


```bash
# test.sh（Shell源码）
#!/bin/bash
sum=0
for ((i=1; i<=10; i++)); do
    sum=$((sum + i))
done
echo "Shell计算1-10的和：$sum"
```


```bash
# 1. 运行（无需编译，Bash解释器逐行执行）
bash test.sh

# 2. 修改源码（比如计算1-20的和），直接重新运行
sed -i 's/10/20/' test.sh
bash test.sh
```

###### 步骤 3：核心差异总结


```bash
#!/bin/bash
# 对比编译型和解释型的执行效率
echo "=== 编译型（C）执行1000次 ==="
time for ((i=1; i<=1000; i++)); do ./test; done > /dev/null

echo -e "\n=== 解释型（Shell）执行1000次 ==="
time for ((i=1; i<=1000; i++)); do bash test.sh; done > /dev/null

# 输出结论
echo -e "\n结论：编译型语言执行效率更高，但解释型语言（Shell）开发/修改更灵活，适合快速自动化场景"
```

### 1.1.2 编程语言逻辑

#### 1.1.2.1 语言分类

语言分类
```powershell
低级编程语言：
机器：
	二进制的0和1的序列，称为机器指令。
	一般人看不懂
汇编：
	用一些助记符号替代机器指令，称为汇编语言。
	一般人看不懂，但是能够有感觉

高级编程语言：
	编译：
		借助于专属编译器将一些高级语言编译成机器代码文件，然后再交给程序去执行。
		如：C，C++ 等
	解释：
		将高级语言的代码逐行加载到解释器环境，逐行解释为机器代码，然后再交给程序去执行。
		如：shell，python，php，JavaScript等
```
#### 1.1.2.2 编程逻辑
```ini
编程语言的目的是通过风格化的编程思路将代码写出来后，实现项目功能的。为了实现功能，我们通过在代码层面通过一些代码逻辑来实现：

顺序执行 - 程序按从上到下顺序执行

选择执行 - 程序执行过程中，根据条件选择不同的顺序执行

循环执行 - 程序执行过程中，根据条件重复执行代码
```

![](assets/Shell%20编程/file-20251204142415093.png)

## 1.2 shell基础

### 1.2.1 shell简介

#### 1.2.1.1 运维是干什么的

简介
![](assets/Shell%20编程/file-20251204143149448.png)

```ini
运维是什么？
所谓的运维，其实就是公司的内部项目当中的一个技术岗位而已，它主要做的是项目的维护性工作。它所涉及的内容范围非常多。

以xx项目为例：

规划：我们需要多少资源来支持项目的运行
管理：项目运行过程中的所有内容都管理起来
流程规范：所有操作都形成制度，提高工作效率
平台：大幅度提高工作效率
监控：实时查看项目运行状态指标
告警：状态指标异常，告知工作人员处理
安全：网站运营安全措施
优化：保证用户访问网站体验很好
考核：权责分配，保证利益

自动化运维：就是将图里面所有的工作都使用自动化的方式来实现。
实现自动化的方式很多，常见的方式：工具和脚本。
工作中常见的脚本有哪些呢？
   shell脚本 和 其他开发语言脚本
```
#### 1.2.1.2 shell语言
![](assets/Shell%20编程/file-20251204143418548.png)
```bash
在计算机科学中，Shell 就是一个命令解释器。

shell 是位于操作系统和应用程序之间，是他们二者最主要的接口，shell 负责把应用程序的输入命令信息解释给操作系统，将操作系统指令处理后的结果解释给应用程序。

一句话，shell 就是在操作系统和应用程序之间的一个命令翻译工具。
```

### 1.2.2 shell 脚本实践

#### 1.2.2.1 脚本基础

shell 脚本
```bash
当可执行的 Linux 命令或语句不在命令行状态下执行，而是通过一个文件执行时，我们称文件为 shell 脚本。

重复化、复杂化的工作，通过把工作的命令写成脚本，以后仅仅需要执行脚本就能完成这些工作。
	自动化分析处理
	自动化备份
	自动化批量部署安装
	等等...
```
#### 1.2.2.2 脚本操作

脚本创建
```bash
脚本创建工具：
创建脚本的常见编辑器是 vi/vim.

脚本命名
shell脚本的命名简单来说就是要有意义，方便我们通过脚本名，来知道这个文件是干什么用的。

脚本内容：
各种可以执行的命令
```

### 1.2.3 脚本注释
注释是 Shell 脚本中对代码逻辑、功能的说明，解释器会忽略注释内容，核心作用是提升脚本可读性、便于维护。Shell 本身仅原生支持**单行注释**，多行注释需通过特殊语法模拟
#### 1.2.3.1 单行注释（核心语法）

##### 1.2.3.1.1 知识点

1. **基本语法**：以 `#` 开头，`#` 后的所有内容均为注释（行内注释需注意位置）；
2. **注意事项**：
    - `#` 必须是行首（或行内非字符串区域），若在字符串（单 / 双引号）内，`#` 会被视为普通字符；
    - `#` 与注释内容间建议加空格（规范，非强制）；
    - 脚本首行的 `#!/bin/bash` 不是注释（Shebang，指定解释器），但 `#!` 仅在第一行有效，第二行及以后的 `#!` 会被视为注释。

##### 1.2.3.1.2 配套代码示例（single_comment.sh）

```bash
#!/bin/bash
# 这是单行注释：脚本功能 - 演示单行注释的各种写法
# 作者：xxx
# 创建时间：2025-12-04

name="Shell"  # 行内注释：定义变量（注意#前加空格，规范写法）
echo "Hello $name"  # 输出变量值

# 错误示例：字符串内的#不是注释
str="注释测试：# 这不是注释"
echo $str  # 输出：注释测试：# 这不是注释

#! 第二行的#!会被视为注释
# 注释可以写TODO：TODO 后续优化变量命名规范
```

#### 1.2.3.2 多行注释（模拟实现）

Shell 无原生多行注释语法，需通过 **空命令 `:`** + **Here Document（HereDoc）** 模拟，以下是 3 种常用方式（推荐第一种）。

##### 1.2.3.2.1 方式 1：`:<<标记符 注释内容 标记符`（最常用）

###### 1.2.3.2.1.1 知识点

- `:` 是 Shell 空命令（执行后无操作，返回值 0）；
- `<<标记符` 表示开始读取内容，直到遇到相同的`标记符`结束（标记符可自定义，如 EOF、!、_ 等）；
- 注释内容中可包含任意字符（包括 #、特殊符号），标记符必须成对且结束标记符需单独一行（无空格）。

###### 1.2.3.2.1.2 配套代码示例（multi_comment1.sh）

```bash
#!/bin/bash
# 演示多行注释（推荐方式）
:<<EOF
这是多行注释块：
1. 脚本用途：批量处理日志文件
2. 核心逻辑：
   - 遍历 /var/log 下的 .log 文件
   - 压缩7天前的日志
   - 删除30天前的日志
3. 注意事项：执行前需确认日志目录权限
EOF

# 业务代码
echo "开始处理日志..."
```

##### 1.2.3.2.2 方式 2：`: 加单行注释堆叠（简单但不优雅）`

###### 1.2.3.2.2.1 知识点

- 每行都以 `#` 开头，适合短注释块；
- 优点：简单直观；缺点：注释 / 取消注释需逐行操作。

###### 1.2.3.2.2.2 配套代码示例（multi_comment2.sh）

```bash
#!/bin/bash
# 多行注释（堆叠式）
# 功能：计算1-100的和
# 实现逻辑：
# 1. 初始化sum=0
# 2. for循环遍历1-100
# 3. 累加求和并输出

sum=0
for ((i=1; i<=100; i++)); do
    sum=$((sum + i))
done
echo "1-100的和：$sum"
```

##### 1.2.3.2.3 方式 3：其他标记符变体（灵活适配场景）

###### 1.2.3.2.3.1 知识点

- 标记符可自定义（如 `!`、`_`、`COMMENT`），避免与注释内容冲突；
- 结束标记符必须**顶行写**（前后无空格、无缩进）。

###### 1.2.3.2.3.2 配套代码示例（multi_comment3.sh）

```bash
#!/bin/bash
# 自定义标记符的多行注释
:<<!
注释内容包含EOF字符：比如"备份文件到 /tmp/EOF/"
使用!作为标记符，避免冲突
!

:<<_
这是另一个多行注释块
标记符为下划线_
_

echo "自定义标记符演示完成"
```

##### 1.2.3.2.4 多行注释注意事项

1. 结束标记符必须单独一行，且**无任何空格 / 缩进**（如下写法错误）：
```bash
:<<EOF
错误示例
  EOF  # 缩进导致注释未结束，脚本报错
```
    
2. 多行注释不能嵌套（如下写法错误）：
    
```bash
    :<<EOF
    外层注释
    :<<!
    内层注释（错误：嵌套不支持）
    !
    EOF
```

    
3. 注释块内避免出现与结束标记符完全一致的内容（会提前终止注释）。

#### 1.2.3.4 注释的最佳实践（规范）

##### 1.2.3.4.1 必加注释的场景

- 脚本开头：注明功能、作者、创建时间、依赖、执行权限；
- 核心逻辑：复杂判断 / 循环、特殊算法的说明；
- 特殊参数：脚本参数的含义、默认值；
- 风险操作：删除 / 修改文件、系统配置变更的提示；
- TODO/FIXME：待优化、待修复的问题。

##### 1.2.3.4.2 规范注释示例（standard_comment.sh）

```bash
#!/bin/bash
##############################################################################
# 脚本名称：log_clean.sh
# 功能描述：自动清理/压缩系统日志，避免磁盘空间耗尽
# 作者：xxx
# 创建时间：2025-12-04
# 依赖环境：bash 4.0+、gzip、find
# 执行权限：需root用户（或sudo权限）
# 使用方式：bash log_clean.sh [日志目录] [保留天数]
#          示例：bash log_clean.sh /var/log 30
##############################################################################

# 定义默认参数
LOG_DIR=${1:-/var/log}  # 参数1：日志目录，默认/var/log
KEEP_DAYS=${2:-30}      # 参数2：保留天数，默认30天

# 校验参数合法性（核心逻辑注释）
if ! [[ $KEEP_DAYS =~ ^[0-9]+$ ]]; then
    echo "错误：保留天数必须是数字！"
    exit 1
fi

# 压缩7天前的日志（风险操作：需确认文件存在）
find $LOG_DIR -name "*.log" -mtime +7 -exec gzip {} \;

# FIXME：后续需添加日志压缩后的备份逻辑
# TODO：增加邮件通知功能，清理完成后发送报告

echo "日志清理完成！保留最近${KEEP_DAYS}天的日志"
```

#### 1.2.3.5 注释常见误区
1. 注释与代码脱节：代码修改后未同步更新注释（导致注释误导）；
2. 过度注释：简单逻辑（如 `i=1`）无需注释，避免冗余；
3. 注释内容模糊：如仅写 “处理数据”，应明确 “处理 /var/log 下的日志数据，过滤空行”；
4. 行内注释滥用：行尾仅注释关键逻辑，避免每行都加行内注释。