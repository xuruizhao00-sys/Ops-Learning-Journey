Shell 编程是 Linux/UNIX 环境下必备的技能，核心是通过脚本自动化执行命令、处理文本、管理系统。本文基于 **Bash（Bourne-Again Shell）**（Linux 默认 Shell）编写

# 一、基础入门：Shell 脚本核心概念
## 1.1 编程介绍
### 1.1.1 编程语言初始
#### 1.1.1.1 基础知识
##### 1.1.1.1.1 核心知识点

1. **编程的本质**：
    
    编程是将人类解决问题的逻辑，转化为计算机能理解并执行的**指令集合**。计算机只能识别二进制（0/1），编程语言作为 “翻译器”，让人类用接近自然语言的方式编写指令，再通过解释器 / 编译器转化为机器码。
2. **Shell 编程的定位**：
    
    Shell 编程是面向 **Linux/UNIX 系统管理、自动化操作** 的脚本编程，核心价值是 “串联系统命令”—— 无需编写复杂逻辑，即可快速实现文件处理、进程管理、批量任务自动化。
3. **计算机执行程序的基本逻辑**：
    - 输入：接收用户 / 文件 / 其他程序的指令 / 数据；
    - 处理：CPU 执行指令（计算、判断、循环等）；
    - 输出：返回结果（屏幕打印、文件写入、状态码等）；
        
        Shell 脚本完全遵循此逻辑，比如 `ls -l` 是 “输入指令”，CPU 执行文件遍历逻辑，最终在终端输出文件列表。
4. **Shell 与操作系统的关系**：
    
    Shell 是用户与操作系统内核（Kernel）之间的 “中间层”：用户编写 Shell 脚本 → Shell 解释器（如 Bash）解析指令 → 调用内核接口执行（如读写文件、创建进程）→ 返回结果给用户。

##### 1.1.1.1.2 配套示例（理解执行逻辑）

```bash
#!/bin/bash
# 演示 Shell 脚本的“输入-处理-输出”逻辑
# 输入：定义变量接收用户输入
read -p "请输入一个数字：" num

# 处理：判断数字奇偶性
if (( num % 2 == 0 )); then
    result="偶数"
else
    result="奇数"
fi

# 输出：打印处理结果
echo "你输入的数字 $num 是 $result"
```
#### 1.1.1.2 编程语言
##### 1.1.1.2.1 核心知识点

1. **编程语言的本质**：
    
    是一套 “语法规则 + 语义定义” 的集合，用于描述 “计算机该做什么、怎么做”。不同编程语言的核心差异在于**设计目标**（如 C 追求效率、Python 追求简洁、Shell 追求系统命令联动）。
2. **Shell 语言的核心特点**：

|特点|说明|
|---|---|
|解释型|无需编译，由 Bash 逐行解析执行（对比 C 编译型语言）|
|弱类型|无需声明变量类型（如 `a=10` 是数值，`a="abc"` 是字符串）|
|命令导向|核心是调用 Linux 系统命令（ls、grep、sed 等），而非原生语法|
|轻量高效|适合短脚本、自动化任务，不适合复杂业务逻辑（如大型应用开发）|

    
3. **Shell 与其他主流语言的对比**

| 语言     | 类型         | 适用场景        | 对比 Shell                    |
| ------ | ---------- | ----------- | --------------------------- |
| C      | 编译型 / 低级语言 | 操作系统、底层组件   | 效率极高，但开发复杂；Shell 依赖 C 编写的内核 |
| Python | 解释型 / 高级语言 | 数据分析、Web 开发 | 语法更优雅，生态更全；Shell 处理系统命令更直接  |
| Java   | 编译 + 解释型   | 大型应用、企业级开发  | 跨平台性强；Shell 无跨平台优势（仅适配 U    |
    
4. **Shell 的版本与选型**：
    - 基础 Shell（sh）：UNIX 原生 Shell，语法简单但功能少；
    - Bash（Bourne-Again Shell）：Linux 默认 Shell，兼容 sh，扩展了变量、循环、函数等功能（本文核心）；
    - Zsh/Fish：增强型 Shell，交互更友好（如自动补全），但脚本兼容性不如 Bash。

##### 1.1.1.2.2 配套示例（Shell 与 Python 实现相同逻辑）

```bash
# Shell 版本：计算1-10的和
#!/bin/bash
sum=0
for ((i=1; i<=10; i++)); do
    sum=$((sum + i))
done
echo "Shell计算1-10的和：$sum"
```

```python
# Python 版本：计算1-10的和（对比参考）
sum = 0
for i in range(1, 11):
    sum += i
print(f"Python计算1-10的和：{sum}")
```

#### 1.1.1.3 编程语言类型
##### 1.1.1.3.1 核心知识点

编程语言可按 **执行方式、抽象层次、用途** 分为不同类型，Shell 属于 “解释型、高级脚本语言、系统级语言”，以下是核心分类及 Shell 的定位：

###### 1.1.1.3.1.1 按执行方式分类（最核心）

|类型|定义|执行流程|代表语言|Shell 归属|
|---|---|---|---|---|
|编译型|编写完成后需通过编译器转化为机器码（二进制文件），运行时直接执行机器码|源码 → 编译 → 可执行文件 → 运行|C、C++、Go|❌ 不属于|
|解释型|无需编译，由解释器逐行解析源码并执行|源码 → 解释器逐行执行|Shell、Python、JavaScript|✅ 典型解释型|

**关键差异**：

- 编译型：一次编译，多次运行（效率高，如 `gcc test.c -o test` 生成可执行文件 `test`）；
- 解释型：每次运行都需解释器（灵活，修改源码后直接运行，无需重新编译）。

###### 1.1.1.3.1.2 按抽象层次分类

|类型|定义|特点|代表语言|Shell 归属|
|---|---|---|---|---|
|低级语言|贴近机器码，直接操作硬件|效率极高，语法晦涩|机器语言、汇编语言|❌ 不属于|
|高级语言|贴近人类自然语言，屏蔽硬件细节|易读易写，开发效率高|Shell、Python、Java|✅ 高级语言|

###### 1.1.1.3.1.3 按用途分类

|类型|定义|代表语言|Shell 归属|
|---|---|---|---|
|系统级语言|面向操作系统管理、硬件交互|C、Shell|✅ 核心用途是系统管理|
|应用级语言|面向业务开发（Web、APP、数据分析）|Python、Java、JavaScript|❌ 不适合复杂应用开发|
|脚本语言|面向自动化任务、批量处理|Shell、Perl、Python|✅ 典型脚本语言|

##### 1.1.1.3.2 配套示例（编译型 vs 解释型 对比演示）

###### 步骤 1：编译型语言（C）示例

```c
// test.c（C语言源码）
#include <stdio.h>
int main() {
    int sum = 0;
    for (int i=1; i<=10; i++) {
        sum += i;
    }
    printf("C语言计算1-10的和：%d\n", sum);
    return 0;
}
```


```bash
# 1. 编译：将C源码转化为可执行文件
gcc test.c -o test

# 2. 运行可执行文件（无需编译器，直接执行）
./test

# 3. 再次运行（无需重新编译）
./test
```

###### 步骤 2：解释型语言（Shell）示例


```bash
# test.sh（Shell源码）
#!/bin/bash
sum=0
for ((i=1; i<=10; i++)); do
    sum=$((sum + i))
done
echo "Shell计算1-10的和：$sum"
```


```bash
# 1. 运行（无需编译，Bash解释器逐行执行）
bash test.sh

# 2. 修改源码（比如计算1-20的和），直接重新运行
sed -i 's/10/20/' test.sh
bash test.sh
```

###### 步骤 3：核心差异总结


```bash
#!/bin/bash
# 对比编译型和解释型的执行效率
echo "=== 编译型（C）执行1000次 ==="
time for ((i=1; i<=1000; i++)); do ./test; done > /dev/null

echo -e "\n=== 解释型（Shell）执行1000次 ==="
time for ((i=1; i<=1000; i++)); do bash test.sh; done > /dev/null

# 输出结论
echo -e "\n结论：编译型语言执行效率更高，但解释型语言（Shell）开发/修改更灵活，适合快速自动化场景"
```

### 1.1.2 编程语言逻辑

#### 1.1.2.1 语言分类

语言分类
```powershell
低级编程语言：
机器：
	二进制的0和1的序列，称为机器指令。
	一般人看不懂
汇编：
	用一些助记符号替代机器指令，称为汇编语言。
	一般人看不懂，但是能够有感觉

高级编程语言：
	编译：
		借助于专属编译器将一些高级语言编译成机器代码文件，然后再交给程序去执行。
		如：C，C++ 等
	解释：
		将高级语言的代码逐行加载到解释器环境，逐行解释为机器代码，然后再交给程序去执行。
		如：shell，python，php，JavaScript等
```
#### 1.1.2.2 编程逻辑
```ini
编程语言的目的是通过风格化的编程思路将代码写出来后，实现项目功能的。为了实现功能，我们通过在代码层面通过一些代码逻辑来实现：

顺序执行 - 程序按从上到下顺序执行

选择执行 - 程序执行过程中，根据条件选择不同的顺序执行

循环执行 - 程序执行过程中，根据条件重复执行代码
```

![](assets/Shell%20编程/file-20251204142415093.png)

## 1.2 shell基础

### 1.2.1 shell简介

#### 1.2.1.1 运维是干什么的

简介
![](assets/Shell%20编程/file-20251204143149448.png)

```ini
运维是什么？
所谓的运维，其实就是公司的内部项目当中的一个技术岗位而已，它主要做的是项目的维护性工作。它所涉及的内容范围非常多。

以xx项目为例：

规划：我们需要多少资源来支持项目的运行
管理：项目运行过程中的所有内容都管理起来
流程规范：所有操作都形成制度，提高工作效率
平台：大幅度提高工作效率
监控：实时查看项目运行状态指标
告警：状态指标异常，告知工作人员处理
安全：网站运营安全措施
优化：保证用户访问网站体验很好
考核：权责分配，保证利益

自动化运维：就是将图里面所有的工作都使用自动化的方式来实现。
实现自动化的方式很多，常见的方式：工具和脚本。
工作中常见的脚本有哪些呢？
   shell脚本 和 其他开发语言脚本
```
#### 1.2.1.2 shell语言
![](assets/Shell%20编程/file-20251204143418548.png)
```bash
在计算机科学中，Shell 就是一个命令解释器。

shell 是位于操作系统和应用程序之间，是他们二者最主要的接口，shell 负责把应用程序的输入命令信息解释给操作系统，将操作系统指令处理后的结果解释给应用程序。

一句话，shell 就是在操作系统和应用程序之间的一个命令翻译工具。
```

### 1.2.2 shell 脚本实践

#### 1.2.2.1 脚本基础

shell 脚本
```bash
当可执行的 Linux 命令或语句不在命令行状态下执行，而是通过一个文件执行时，我们称文件为 shell 脚本。

重复化、复杂化的工作，通过把工作的命令写成脚本，以后仅仅需要执行脚本就能完成这些工作。
	自动化分析处理
	自动化备份
	自动化批量部署安装
	等等...
```
#### 1.2.2.2 脚本操作

脚本创建
```bash
脚本创建工具：
创建脚本的常见编辑器是 vi/vim.

脚本命名
shell脚本的命名简单来说就是要有意义，方便我们通过脚本名，来知道这个文件是干什么用的。

脚本内容：
各种可以执行的命令
```

#### 1.2.2.3 脚本实践
```bash
15:14:38 root@redis01:~# cat net_info.sh
# ==============================================================================
# 脚本基础信息
# filename: net_info.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 获取ip地址信息
ifconfig ens33 | grep -w inet | awk '{print $2}' | xargs echo "IP: "
# 获取掩码地址信息
ifconfig ens33 | grep -w inet | awk '{print $4}' | xargs echo "NetMask: "
# 获取广播地址信息
ifconfig ens33 | grep -w inet | awk '{print $6}' | xargs echo "Broadcast: "
# 获取 MAC 地址信息
ifconfig ens33 | grep ether | awk '{print $2}' |xargs echo "MAC Address: "

# 执行脚本
15:14:40 root@redis01:~# bash net_info.sh
IP:  192.168.121.131
NetMask:  255.255.255.0
Broadcast:  192.168.121.255
MAC Address:  00:0c:29:b4:8d:6a
15:14:43 root@redis01:~#
```
### 1.2.3 脚本注释
注释是 Shell 脚本中对代码逻辑、功能的说明，解释器会忽略注释内容，核心作用是提升脚本可读性、便于维护。Shell 本身仅原生支持**单行注释**，多行注释需通过特殊语法模拟
#### 1.2.3.1 单行注释（核心语法）

##### 1.2.3.1.1 知识点

1. **基本语法**：以 `#` 开头，`#` 后的所有内容均为注释（行内注释需注意位置）；
2. **注意事项**：
    - `#` 必须是行首（或行内非字符串区域），若在字符串（单 / 双引号）内，`#` 会被视为普通字符；
    - `#` 与注释内容间建议加空格（规范，非强制）；
    - 脚本首行的 `#!/bin/bash` 不是注释（Shebang，指定解释器），但 `#!` 仅在第一行有效，第二行及以后的 `#!` 会被视为注释。

##### 1.2.3.1.2 配套代码示例（single_comment.sh）

```bash
#!/bin/bash
# 这是单行注释：脚本功能 - 演示单行注释的各种写法
# 作者：xxx
# 创建时间：2025-12-04

name="Shell"  # 行内注释：定义变量（注意#前加空格，规范写法）
echo "Hello $name"  # 输出变量值

# 错误示例：字符串内的#不是注释
str="注释测试：# 这不是注释"
echo $str  # 输出：注释测试：# 这不是注释

#! 第二行的#!会被视为注释
# 注释可以写TODO：TODO 后续优化变量命名规范
```

#### 1.2.3.2 多行注释（模拟实现）

Shell 无原生多行注释语法，需通过 **空命令 `:`** + **Here Document（HereDoc）** 模拟，以下是 3 种常用方式（推荐第一种）。

##### 1.2.3.2.1 方式 1：`:<<标记符 注释内容 标记符`（最常用）

###### 1.2.3.2.1.1 知识点

- `:` 是 Shell 空命令（执行后无操作，返回值 0）；
- `<<标记符` 表示开始读取内容，直到遇到相同的`标记符`结束（标记符可自定义，如 EOF、!、_ 等）；
- 注释内容中可包含任意字符（包括 #、特殊符号），标记符必须成对且结束标记符需单独一行（无空格）。

###### 1.2.3.2.1.2 配套代码示例（multi_comment1.sh）

```bash
#!/bin/bash
# 演示多行注释（推荐方式）
:<<EOF
这是多行注释块：
1. 脚本用途：批量处理日志文件
2. 核心逻辑：
   - 遍历 /var/log 下的 .log 文件
   - 压缩7天前的日志
   - 删除30天前的日志
3. 注意事项：执行前需确认日志目录权限
EOF

# 业务代码
echo "开始处理日志..."
```

##### 1.2.3.2.2 方式 2：`: 加单行注释堆叠（简单但不优雅）`

###### 1.2.3.2.2.1 知识点

- 每行都以 `#` 开头，适合短注释块；
- 优点：简单直观；缺点：注释 / 取消注释需逐行操作。

###### 1.2.3.2.2.2 配套代码示例（multi_comment2.sh）

```bash
#!/bin/bash
# 多行注释（堆叠式）
# 功能：计算1-100的和
# 实现逻辑：
# 1. 初始化sum=0
# 2. for循环遍历1-100
# 3. 累加求和并输出

sum=0
for ((i=1; i<=100; i++)); do
    sum=$((sum + i))
done
echo "1-100的和：$sum"
```

##### 1.2.3.2.3 方式 3：其他标记符变体（灵活适配场景）

###### 1.2.3.2.3.1 知识点

- 标记符可自定义（如 `!`、`_`、`COMMENT`），避免与注释内容冲突；
- 结束标记符必须**顶行写**（前后无空格、无缩进）。

###### 1.2.3.2.3.2 配套代码示例（multi_comment3.sh）

```bash
#!/bin/bash
# 自定义标记符的多行注释
:<<!
注释内容包含EOF字符：比如"备份文件到 /tmp/EOF/"
使用!作为标记符，避免冲突
!

:<<_
这是另一个多行注释块
标记符为下划线_
_

echo "自定义标记符演示完成"
```

##### 1.2.3.2.4 多行注释注意事项

1. 结束标记符必须单独一行，且**无任何空格 / 缩进**（如下写法错误）：
```bash
:<<EOF
错误示例
  EOF  # 缩进导致注释未结束，脚本报错
```
    
2. 多行注释不能嵌套（如下写法错误）：
    
```bash
    :<<EOF
    外层注释
    :<<!
    内层注释（错误：嵌套不支持）
    !
    EOF
```

    
3. 注释块内避免出现与结束标记符完全一致的内容（会提前终止注释）。

#### 1.2.3.4 注释的最佳实践（规范）

##### 1.2.3.4.1 必加注释的场景

- 脚本开头：注明功能、作者、创建时间、依赖、执行权限；
- 核心逻辑：复杂判断 / 循环、特殊算法的说明；
- 特殊参数：脚本参数的含义、默认值；
- 风险操作：删除 / 修改文件、系统配置变更的提示；
- TODO/FIXME：待优化、待修复的问题。

##### 1.2.3.4.2 规范注释示例（standard_comment.sh）

```bash
#!/bin/bash
##############################################################################
# 脚本名称：log_clean.sh
# 功能描述：自动清理/压缩系统日志，避免磁盘空间耗尽
# 作者：xxx
# 创建时间：2025-12-04
# 依赖环境：bash 4.0+、gzip、find
# 执行权限：需root用户（或sudo权限）
# 使用方式：bash log_clean.sh [日志目录] [保留天数]
#          示例：bash log_clean.sh /var/log 30
##############################################################################

# 定义默认参数
LOG_DIR=${1:-/var/log}  # 参数1：日志目录，默认/var/log
KEEP_DAYS=${2:-30}      # 参数2：保留天数，默认30天

# 校验参数合法性（核心逻辑注释）
if ! [[ $KEEP_DAYS =~ ^[0-9]+$ ]]; then
    echo "错误：保留天数必须是数字！"
    exit 1
fi

# 压缩7天前的日志（风险操作：需确认文件存在）
find $LOG_DIR -name "*.log" -mtime +7 -exec gzip {} \;

# FIXME：后续需添加日志压缩后的备份逻辑
# TODO：增加邮件通知功能，清理完成后发送报告

echo "日志清理完成！保留最近${KEEP_DAYS}天的日志"
```

#### 1.2.3.5 注释常见误区
1. 注释与代码脱节：代码修改后未同步更新注释（导致注释误导）；
2. 过度注释：简单逻辑（如 `i=1`）无需注释，避免冗余；
3. 注释内容模糊：如仅写 “处理数据”，应明确 “处理 /var/log 下的日志数据，过滤空行”；
4. 行内注释滥用：行尾仅注释关键逻辑，避免每行都加行内注释。

### 1.2.4 脚本执行方式
#### 1.2.4.1 核心概念铺垫
在讲解执行方式前，先明确两个关键概念：

1. **子 Shell**：执行脚本时新建的 Shell 进程，子 Shell 的环境变量 / 修改不会同步到父 Shell；
2. **执行权限**：脚本文件需具备`x`（执行）权限（`chmod +x`），部分方式可绕过；
3. **当前 Shell 环境**：终端当前的进程环境（如已定义的变量、别名等）。

#### 1.2.4.2 方式一：直接执行（赋予执行权限后运行）
##### 1.2.4.2.1 核心语法
```bash
# 步骤1：赋予执行权限（仅需执行一次）
chmod +x 脚本名.sh

# 步骤2：执行（需指定路径，相对/绝对均可）
./脚本名.sh        # 相对路径（当前目录）
/绝对路径/脚本名.sh # 绝对路径（如 /root/scripts/test.sh）
```

##### 1.2.4.2.2 案例
```bash
15:57:37 root@redis01:~# cat test01.sh
# ==============================================================================
# 脚本基础信息
# filename: test01.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 演示直接执行的特点
export TEST_VAR="直接执行-子Shell变量"
echo "脚本内的TEST_VAR：$TEST_VAR"
echo "当前Shell进程ID（PID）：$$" # $$表示当前进程ID

15:57:39 root@redis01:~# chmod +x test01.sh
15:57:54 root@redis01:~# ls -l test01.sh
-rwxr-xr-x 1 root root 486 Dec  4 15:57 test01.sh

# 直接执行（相对路径）
# 输出示例：
# 脚本内的TEST_VAR：直接执行-子Shell变量
# 当前Shell进程ID（PID）：12345（随机数，与终端PID不同）
15:57:59 root@redis01:~# ./test01.sh 
脚本内的TEST_VAR：直接执行-子Shell变量
当前Shell进程ID（PID）：17051

# 验证是否修改当前 Shell 环境
# 输出：终端的TEST_VAR：（空，子 Shell 变量不回传）
15:58:06 root@redis01:~# echo "终端的TEST_VAR：$TEST_VAR"
终端的TEST_VAR：
15:58:42 root@redis01:~# 

```

##### 1.2.4.2.3 适用场景
- 生产环境中独立运行的脚本（如自动化部署、日志清理、定时任务核心脚本）；
- 脚本需要作为可执行程序独立分发 / 运行；
- 希望脚本在子 Shell 中运行，避免污染当前终端环境（如修改环境变量、定义函数）。
##### 1.2.4.2.4 注意事项
- 必须指定路径（`./`或绝对路径），否则系统会在`$PATH`中查找，若当前目录不在`$PATH`则报错（如直接输`exec_direct.sh`会提示 “命令未找到”）；
- 脚本首行`#!/bin/bash`（Shebang）必须正确，否则可能执行失败（如指定不存在的解释器`#!/bin/xxx`）；
- 执行权限仅需赋予一次，后续可重复执行。
#### 1.2.4.3 方式二：通过解释器直接执行（bash/sh 脚本.sh）
##### 1.2.4.3.1 核心语法
```bash
bash 脚本名.sh [参数]  # 使用Bash解释器（推荐）
sh 脚本名.sh [参数]    # 使用sh解释器（兼容模式）
zsh 脚本名.sh [参数]   # 其他Shell解释器（如zsh/ksh）
```

##### 1.2.4.3.2 配套案例
```bash
16:06:05 root@redis01:~# cat test02.sh 
# ==============================================================================
# 脚本基础信息
# filename: test02.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 演示解释器执行的特点
echo "使用的解释器：$SHELL"
echo "脚本参数1：$1"  # 接收命令行参数
export INTERP_VAR="解释器执行-子Shell变量"
echo "脚本内的INTERP_VAR：$INTERP_VAR"


# 1. 无需赋予执行权限，直接用bash执行（传参）
bash exec_interpreter.sh 测试参数
# 输出示例：
# 使用的解释器：/bin/bash
# 脚本参数1：测试参数
# 脚本内的INTERP_VAR：解释器执行-子Shell变量

# 2. 验证当前Shell环境（变量未同步）
echo "终端的INTERP_VAR：$INTERP_VAR"
# 输出：终端的INTERP_VAR：（空）

# 3. 用sh执行（兼容模式，注意Bash扩展语法可能报错）
sh exec_interpreter.sh
# 若脚本含[[ ]]、C风格for循环等Bash扩展语法，sh执行会报错
```

##### 1.2.4.3.3 适用场景
- 脚本未赋予执行权限（如临时测试、只读文件、共享目录下的脚本）；
- 需要指定特定解释器运行（如用`sh`兼容模式验证脚本跨 Shell 兼容性）；
- 开发 / 调试阶段快速测试脚本，无需频繁修改权限。
##### 1.2.4.3.4 注意事项
- 无需执行权限，但脚本文件需有**读权限**（`r`）（如`chmod 400 脚本.sh`仍可执行）；
- 若脚本首行 Shebang 与执行时指定的解释器冲突，以执行时指定的为准（如 Shebang 是`#!/bin/sh`，但用`bash`执行则用 Bash）；
- `sh`是 Bash 的兼容模式，部分 Bash 扩展语法（如`[[ ]]`、`for ((i=1; i<=10; i++))`）在`sh`下会报错。
#### 1.2.4.3 方式三：source / 点命令执行（source 脚本.sh/. 脚本.sh）
##### 1.2.4.3.1 核心语法
```bash
source 脚本名.sh [参数]  # 方式1（直观）
. 脚本名.sh [参数]       # 方式2（点+空格+脚本名，空格不可省略）
```
##### 1.2.4.3.2 配套案例
```bash
16:09:50 root@redis01:~# cat test03.sh
# ==============================================================================
# 脚本基础信息
# filename: test03.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 演示source执行的特点
export SOURCE_VAR="source执行-当前Shell变量"
echo "脚本内的SOURCE_VAR：$SOURCE_VAR"
echo "当前Shell进程ID（PID）：$$" # 与终端PID一致

# 定义一个函数（仅当前Shell有效）
hello() {
    echo "Hello from source script! 参数：$1"
}


# 1. 无需执行权限，source执行（传参）
source test03.sh 测试参数
# 输出示例：
# 脚本内的SOURCE_VAR：source执行-当前Shell变量
# 当前Shell进程ID（PID）：6789（与终端PID相同）

# 2. 验证当前Shell环境（变量已生效）
echo "终端的SOURCE_VAR：$SOURCE_VAR"
# 输出：终端的SOURCE_VAR：source执行-当前Shell变量

# 3. 调用脚本内定义的函数（已生效）
hello 世界
# 输出：Hello from source script! 参数：世界

# 4. 用点命令执行（等价source）
. exec_source.sh
```

##### 1.2.4.3.3 适用场景

- 需要修改当前 Shell 环境的场景（如定义环境变量、别名、函数）；
- 加载系统 / 项目配置文件（如`source ~/.bashrc`、`source /etc/profile`）；
- 脚本中的变量 / 函数需要在终端后续操作中使用（如项目启动前的环境配置）；
- 批量设置环境变量（如`export PATH=/usr/local/bin:$PATH`）。
##### 1.2.4.3.4 注意事项

- 不创建子 Shell，脚本的所有修改（变量、函数、别名）都会直接影响当前终端；
- 无需执行权限，但需读权限；
- 脚本中的`exit`命令会直接退出当前终端（而非仅退出脚本），需慎用；
- 路径规则：若脚本不在当前目录，需指定相对 / 绝对路径（如`source ../config.sh`）
#### 1.2.4.4 方式四：重定向执行（sh < 脚本.sh）
##### 1.2.4.4.1 核心语法
```bash
bash < 脚本名.sh [参数]  # Bash解释器
sh < 脚本名.sh [参数]    # sh解释器

# 扩展：远程脚本管道执行（最常用场景）
curl -s http://example.com/remote.sh | bash
```

##### 1.2.4.4.2 配套案例
```bash
#!/bin/bash
# 演示重定向执行的特点
echo "重定向执行-脚本参数1：$1"  # 注意：参数无法传递！
export REDIRECT_VAR="重定向执行-子Shell变量"
echo "脚本内的REDIRECT_VAR：$REDIRECT_VAR"


# 1. 重定向执行（尝试传参，无效）
bash < exec_redirect.sh 测试参数
# 输出：
# 重定向执行-脚本参数1：（空，参数无法传递）
# 脚本内的REDIRECT_VAR：重定向执行-子Shell变量

# 2. 验证当前环境（变量未同步）
echo "终端的REDIRECT_VAR：$REDIRECT_VAR"
# 输出：终端的REDIRECT_VAR：（空）

# 3. 远程脚本管道执行（示例，仅演示语法）
# curl -s https://raw.githubusercontent.com/xxx/test.sh | bash
```

##### 1.2.4.4.3 适用场景
- 脚本文件来自标准输入（如远程下载后直接执行、管道传输的脚本内容）；
- 临时执行无本地文件的脚本（如快速测试网上的脚本片段）；
- 自动化部署中 “一键执行” 远程脚本（如`curl | bash`）。

##### 1.2.4.4.4 注意事项
- 无法向脚本传递命令行参数（`$1`、`$2`等为空）；
- 创建子 Shell，不修改当前环境；
- 脚本首行的 Shebang 会被忽略（解释器由执行时指定的`bash/sh`决定）；
- 风险提示：远程脚本管道执行（`curl | bash`）需确认脚本来源安全，避免执行恶意代码
#### 1.2.4.5 方式五：作为函数/别名执行
##### 1.2.4.5.1 核心语法
```bash
# 方式1：将脚本内容封装为函数（当前Shell生效）
function 函数名() {
    # 原脚本核心逻辑
}

# 方式2：别名执行（简化长命令）
alias 别名="bash /绝对路径/脚本名.sh [固定参数]"
```

##### 1.2.4.5.2 配套案例
```bash
#!/bin/bash
# 定义函数（替代独立脚本文件）
log_clean() {
    # 核心逻辑：清理7天前的日志文件
    find /var/log -name "*.log" -mtime +7 -delete
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] 日志清理完成！"
}

# 执行函数（当前Shell生效）
log_clean

# 后续终端可重复调用
# log_clean
```

```bash
# 1. 定义临时别名（终端关闭后失效）
alias clean_log="bash /root/scripts/log_clean.sh"

# 2. 执行别名
clean_log

# 3. 永久生效：将别名写入~/.bashrc
echo "alias clean_log='bash /root/scripts/log_clean.sh'" >> ~/.bashrc
source ~/.bashrc  # 立即生效（无需重启终端）
```
##### 1.2.4.5.3 适用场景
- 脚本逻辑需要频繁复用（如日常运维命令：日志清理、服务重启）；
- 简化长路径 / 复杂参数的脚本执行（如`alias deploy='bash /data/project/deploy.sh prod'`）；
- 脚本逻辑较短，无需单独文件存储（如几行的小工具）。
##### 1.2.4.5.4 注意事项
- 函数执行在当前 Shell 环境（类似 source），变量 / 修改会影响当前终端；
- 别名本质是 “解释器执行” 的封装，创建子 Shell，不修改当前环境；
- 永久别名需写入`~/.bashrc`（普通用户）或`/etc/bashrc`（全局），并 source 生效；
- 别名若与系统命令重名，需用`\命令名`执行原生命令（如`\ls`跳过 ls 别名）。
#### 1.2.4.6 方式六：定时执行（crontab）
##### 1.2.4.6.1 核心语法
```bash
# 步骤1：编辑crontab定时任务
crontab -e

# 步骤2：添加定时规则（分 时 日 月 周 执行命令）
*/30 * * * * bash /绝对路径/脚本名.sh > /tmp/脚本日志.log 2>&1
```
#### 1.2.4.7 各执行方式对比 & 选型建议
|执行方式|是否需执行权限|是否创建子 Shell|是否修改当前环境|能否传参|核心适用场景|
|---|---|---|---|---|---|
|直接执行（./ 脚本.sh）|是|是|否|能|独立运行的生产脚本|
|解释器执行（bash 脚本）|否|是|否|能|临时测试、指定解释器|
|source / 点命令|否|否|是|能|加载配置、修改当前环境|
|重定向执行（bash < 脚本）|否|是|否|否|远程脚本、标准输入执行|
|函数 / 别名执行|无（无文件）|函数：否 / 别名：是|函数：是 / 别名：否|能|频繁复用、简化命令|
|crontab 定时执行|建议是|是|否|能|周期性后台任务|
选型核心原则

1. 若需修改当前环境（变量 / 函数 / 别名）→ 选 `source`/ 函数执行；
2. 若独立运行、不污染环境 → 选 直接执行 / 解释器执行；
3. 若远程 / 无文件执行 → 选 重定向执行（`curl | bash`）；
4. 若周期性任务 → 选 crontab 定时执行；
5. 若频繁复用 → 选 函数 / 别名执行。

### 1.2.5 脚本调试方式
Shell 脚本调试的核心目标是定位**语法错误**、**逻辑错误**、**变量值异常**、**命令执行失败**等问题。根据脚本复杂度和调试需求，可分为「解释器级调试（bash 内置参数）」「脚本内精细化调试」「实战技巧 / 第三方工具」三类
#### 1.2.5.1 核心概念
1. **语法错误**：违反 Shell 语法规则（如少写 `done`、括号不匹配），脚本直接无法执行；
2. **逻辑错误**：语法合法但结果不符合预期（如循环次数错误、变量值为空）；
3. **调试输出**：通过打印命令、变量、执行流程，还原脚本运行过程；
4. **静态检查**：不执行脚本，提前检测语法 / 规范 / 潜在问题。
#### 1.2.5.2 方式 1：bash 内置调试参数（最常用）
bash 提供了一系列内置参数，可直接通过命令行传递，快速开启调试模式，无需修改脚本内容。

|参数|核心作用|语法示例|适用场景|
|---|---|---|---|
|`-n`|检查语法错误，**不执行脚本**|`bash -n script.sh`|快速验证脚本语法合法性（如写完脚本第一步检查）|
|`-x`|跟踪执行过程，打印每一步命令（展开变量）|`bash -x script.sh`|定位逻辑错误（如变量值异常、循环 / 判断逻辑错误）|
|`-v`|打印脚本原始内容 + 执行过程（不展开变量）|`bash -v script.sh`|确认脚本是否被正确读取（如路径 / 编码问题）|
|`-e`|任意命令执行失败（返回值≠0）立即退出脚本|`bash -e script.sh`|避免错误扩散（如某步命令失败后，脚本仍继续执行导致更多问题）|
|`-u`|使用**未定义变量**时立即报错|`bash -u script.sh`|定位因变量未定义 / 为空导致的逻辑错误|
|`-o xtrace`|等价 `-x`，可结合其他参数（如 `-o errexit` 等价 `-e`）|`bash -o xtrace -o errexit script.sh`|多参数组合调试|

##### 1.2.5.2.1 基础参数案例（单参数调试）
###### 1.2.5.2.1.1 -n 检查语法错误
```bash
16:31:30 root@redis01:~# cat test1.sh
# ==============================================================================
# 脚本基础信息
# filename: test1.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 语法错误：for循环缺少done
sum=0
for ((i=1; i<=10; i++)) {
    sum=$((sum + i))
# 缺少done
echo "1-10的和：$sum"

16:31:31 root@redis01:~# bash -n test1.sh 
# 输出报错（定位语法错误行）：
test1.sh: line 17: syntax error: unexpected end of file
16:31:36 root@redis01:~# 

```
###### 1.2.5.2.1.2 -x 跟踪执行过程⭐⭐⭐
```bash
16:33:30 root@redis01:~# cat debug.sh
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 计算1-10的偶数和
sum=0
for ((i=1; i<=10; i++)); do
    if ((i % 2 == 0)); then
        sum=$((sum + i))
    fi
done
echo "1-10偶数和：$sum"

# 执行调试（-x 会打印每一步执行的命令和变量值）：
16:33:33 root@redis01:~# bash -x debug.sh 
+ sum=0
+ (( i=1 ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ sum=2
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ sum=6
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ sum=12
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ sum=20
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ sum=30
+ (( i++ ))
+ (( i<=10 ))
+ echo 1-10偶数和：30
1-10偶数和：30

```
**关键**：通过 `-x` 可清晰看到循环次数、变量 `i` 和 `sum` 的变化，快速定位逻辑错误（如循环条件写错、判断条件错误）。

###### 1.2.5.2.1.3 -e 命令失败立即退出
```bash
16:35:13 root@redis01:~# cat debug.sh
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 演示-e参数：执行错误命令后立即退出
ls /xxx  # 不存在的目录，执行失败
echo "这行不会执行"  # 因-e参数，上一步失败后脚本直接退出
16:35:14 root@redis01:~# bash -e debug.sh 
# 输出：
# ls: 无法访问'/xxx': 没有那个文件或目录
# （无后续echo输出，脚本已退出）
ls: cannot access '/xxx': No such file or directory
16:35:18 root@redis01:~#
```
###### 1.2.5.2.1.4 -u 未定义变量报错
```bash
16:36:38 root@redis01:~# cat debug.sh
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 演示-u参数：使用未定义变量
echo "未定义变量：$undefined_var"
echo "这行不会执行"

16:36:39 root@redis01:~# bash -u debug.sh
debug.sh: line 11: undefined_var: unbound variable
16:36:44 root@redis01:~# 

```
##### 1.2.5.2.2 组合参数调试
多个参数组合可覆盖更多调试场景，比如：
```bash
# 组合：语法检查(-n) + 执行失败退出(-e) + 未定义变量报错(-u) + 跟踪执行(-x)
bash -n -e -u -x script.sh

# 等价简写（-o 方式）
bash -o errexit -o nounset -o xtrace script.sh
```

#### 1.2.5.3 方式 2：脚本内精细化调试（set 指令）
当脚本较长时，全局 `-x` 会输出大量日志，可通过 `set` 指令在脚本内**局部开启 / 关闭调试**，只调试关键代码段。
##### 1.2.5.3.1 核心语法
```bash
set -x  # 开启调试（等价bash -x）
set +x  # 关闭调试
set -e  # 开启“命令失败立即退出”
set +e  # 关闭“命令失败立即退出”
set -u  # 开启“未定义变量报错”
set +u  # 关闭“未定义变量报错”
```
##### 1.2.5.3.2 配套案例
```bash
16:40:24 root@redis01:~# cat debug.sh
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 脚本内局部调试示例
echo "这部分不调试"

# 开启调试（只调试循环部分）
set -x
sum=0
for ((i=1; i<=5; i++)); do
    sum=$((sum + i))
done
set +x  # 关闭调试

echo "调试结束，总和：$sum"
echo "这部分也不调试"

16:40:25 root@redis01:~# bash debug.sh
这部分不调试
+ sum=0
+ (( i=1 ))
+ (( i<=5 ))
+ sum=1
+ (( i++ ))
+ (( i<=5 ))
+ sum=3
+ (( i++ ))
+ (( i<=5 ))
+ sum=6
+ (( i++ ))
+ (( i<=5 ))
+ sum=10
+ (( i++ ))
+ (( i<=5 ))
+ sum=15
+ (( i++ ))
+ (( i<=5 ))
+ set +x
调试结束，总和：15
这部分也不调试

```
##### 1.2.5.3.3 进阶：自定义调试输出格式
通过 `PS4` 变量可自定义 `-x` 的调试前缀，显示行号、函数名等，便于定位问题：
```bash
16:41:46 root@redis01:~# cat debug.sh 
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 自定义调试输出格式：显示行号+命令
export PS4='[行号:$LINENO] '
set -x

sum=0
for ((i=1; i<=3; i++)); do
    sum=$((sum + i))
done
set +x

echo "总和：$sum"
16:41:48 root@redis01:~# bash debug.sh
[行号:14] sum=0
[行号:15] (( i=1 ))
[行号:15] (( i<=3 ))
[行号:16] sum=1
[行号:15] (( i++ ))
[行号:15] (( i<=3 ))
[行号:16] sum=3
[行号:15] (( i++ ))
[行号:15] (( i<=3 ))
[行号:16] sum=6
[行号:15] (( i++ ))
[行号:15] (( i<=3 ))
[行号:18] set +x
总和：6

```

#### 1.2.5.4 方式 3：实战调试技巧（低成本高效）
对于复杂脚本，结合以下技巧可快速定位问题，无需依赖复杂工具。

##### 1.2.5.4.1 关键位置打印变量 / 状态

在脚本的判断、循环、函数前后，手动添加 `echo`/`printf` 打印变量值、命令返回值，是最基础且有效的调试方式。

```bash
16:44:03 root@redis01:~# cat debug.sh 
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 手动打印变量调试
read -p "请输入数字：" num

# 打印输入的变量值（验证是否正确接收）
echo "【调试】输入的num值：$num，类型：$(file -b <(echo $num))"

# 校验是否为数字
if ! [[ $num =~ ^[0-9]+$ ]]; then
    echo "错误：输入不是数字"
    exit 1
fi

# 打印计算过程
sum=$((num * 2))
echo "【调试】num*2的结果：$sum"

echo "最终结果：$sum"
16:44:06 root@redis01:~# bash debug.sh
请输入数字：4
【调试】输入的num值：4，类型：symbolic link to pipe:[96197]
【调试】num*2的结果：8
最终结果：8
16:44:10 root@redis01:~#
```
##### 1.2.5.4.2 捕获错误信号
通过 `trap` 捕获脚本执行中的错误（`ERR` 信号），自动打印出错行、变量值，无需手动加 `echo`。
###### 1.2.5.4.2.1 trap 测试
```bash
16:51:41 root@redis01:~# cat debug.sh 
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 捕获ERR信号，打印出错信息
trap 'echo "【错误】行号$LINENO执行失败！当前变量：num=$num"; exit 1' ERR

num="abc"  # 非数字，导致后续计算失败
((sum = num * 2))  # 这行会触发ERR信号
echo "不会执行到这里"

16:51:42 root@redis01:~# bash debug.sh 
【错误】行号14执行失败！当前变量：num=abc
16:51:43 root@redis01:~#
```

###### 1.2.5.4.2.2 ERR 信号触发规则
`ERR` 信号仅在 **“简单命令” 执行失败（返回值≠0）** 时触发，而 `$((...))` 属于「参数扩展」（不是独立的 “简单命令”），其内部语法错误不会改变整个命令的返回码，也不会触发 `ERR`。

|语法类型|是否为 “简单命令”|错误是否返回非 0|是否触发 ERR|
|---|---|---|---|
|`$((num*2))`（算术扩展）|否（参数扩展）|否（脚本继续执行）|❌ 不触发|
|`let num*2`（let 命令）|是（独立命令）|是（返回非 0）|✅ 触发|
|`((num*2))`（算术命令）|是（独立命令）|是（返回非 0）|✅ 触发|
