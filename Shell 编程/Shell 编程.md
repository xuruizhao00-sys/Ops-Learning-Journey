Shell 编程是 Linux/UNIX 环境下必备的技能，核心是通过脚本自动化执行命令、处理文本、管理系统。本文基于 **Bash（Bourne-Again Shell）**（Linux 默认 Shell）编写

# 一、基础入门：Shell 脚本核心概念
## 1.1 编程介绍
### 1.1.1 编程语言初始
#### 1.1.1.1 基础知识
##### 1.1.1.1.1 核心知识点

1. **编程的本质**：
    
    编程是将人类解决问题的逻辑，转化为计算机能理解并执行的**指令集合**。计算机只能识别二进制（0/1），编程语言作为 “翻译器”，让人类用接近自然语言的方式编写指令，再通过解释器 / 编译器转化为机器码。
2. **Shell 编程的定位**：
    
    Shell 编程是面向 **Linux/UNIX 系统管理、自动化操作** 的脚本编程，核心价值是 “串联系统命令”—— 无需编写复杂逻辑，即可快速实现文件处理、进程管理、批量任务自动化。
3. **计算机执行程序的基本逻辑**：
    - 输入：接收用户 / 文件 / 其他程序的指令 / 数据；
    - 处理：CPU 执行指令（计算、判断、循环等）；
    - 输出：返回结果（屏幕打印、文件写入、状态码等）；
        
        Shell 脚本完全遵循此逻辑，比如 `ls -l` 是 “输入指令”，CPU 执行文件遍历逻辑，最终在终端输出文件列表。
4. **Shell 与操作系统的关系**：
    
    Shell 是用户与操作系统内核（Kernel）之间的 “中间层”：用户编写 Shell 脚本 → Shell 解释器（如 Bash）解析指令 → 调用内核接口执行（如读写文件、创建进程）→ 返回结果给用户。

##### 1.1.1.1.2 配套示例（理解执行逻辑）

```bash
#!/bin/bash
# 演示 Shell 脚本的“输入-处理-输出”逻辑
# 输入：定义变量接收用户输入
read -p "请输入一个数字：" num

# 处理：判断数字奇偶性
if (( num % 2 == 0 )); then
    result="偶数"
else
    result="奇数"
fi

# 输出：打印处理结果
echo "你输入的数字 $num 是 $result"
```
#### 1.1.1.2 编程语言
##### 1.1.1.2.1 核心知识点

1. **编程语言的本质**：
    
    是一套 “语法规则 + 语义定义” 的集合，用于描述 “计算机该做什么、怎么做”。不同编程语言的核心差异在于**设计目标**（如 C 追求效率、Python 追求简洁、Shell 追求系统命令联动）。
2. **Shell 语言的核心特点**：

| 特点   | 说明                                     |
| ---- | -------------------------------------- |
| 解释型  | 无需编译，由 Bash 逐行解析执行（对比 C 编译型语言）         |
| 弱类型  | 无需声明变量类型（如 `a=10` 是数值，`a="abc"` 是字符串）  |
| 命令导向 | 核心是调用 Linux 系统命令（ls、grep、sed 等），而非原生语法 |
| 轻量高效 | 适合短脚本、自动化任务，不适合复杂业务逻辑（如大型应用开发）         |

    
3. **Shell 与其他主流语言的对比**

| 语言     | 类型         | 适用场景        | 对比 Shell                    |
| ------ | ---------- | ----------- | --------------------------- |
| C      | 编译型 / 低级语言 | 操作系统、底层组件   | 效率极高，但开发复杂；Shell 依赖 C 编写的内核 |
| Python | 解释型 / 高级语言 | 数据分析、Web 开发 | 语法更优雅，生态更全；Shell 处理系统命令更直接  |
| Java   | 编译 + 解释型   | 大型应用、企业级开发  | 跨平台性强；Shell 无跨平台优势（仅适配 U    |
    
4. **Shell 的版本与选型**：
    - 基础 Shell（sh）：UNIX 原生 Shell，语法简单但功能少；
    - Bash（Bourne-Again Shell）：Linux 默认 Shell，兼容 sh，扩展了变量、循环、函数等功能（本文核心）；
    - Zsh/Fish：增强型 Shell，交互更友好（如自动补全），但脚本兼容性不如 Bash。

##### 1.1.1.2.2 配套示例（Shell 与 Python 实现相同逻辑）

```bash
# Shell 版本：计算1-10的和
#!/bin/bash
sum=0
for ((i=1; i<=10; i++)); do
    sum=$((sum + i))
done
echo "Shell计算1-10的和：$sum"
```

```python
# Python 版本：计算1-10的和（对比参考）
sum = 0
for i in range(1, 11):
    sum += i
print(f"Python计算1-10的和：{sum}")
```

#### 1.1.1.3 编程语言类型
##### 1.1.1.3.1 核心知识点

编程语言可按 **执行方式、抽象层次、用途** 分为不同类型，Shell 属于 “解释型、高级脚本语言、系统级语言”，以下是核心分类及 Shell 的定位：

###### 1.1.1.3.1.1 按执行方式分类（最核心）

| 类型  | 定义                                  | 执行流程                 | 代表语言                    | Shell 归属 |
| --- | ----------------------------------- | -------------------- | ----------------------- | -------- |
| 编译型 | 编写完成后需通过编译器转化为机器码（二进制文件），运行时直接执行机器码 | 源码 → 编译 → 可执行文件 → 运行 | C、C++、Go                | ❌ 不属于    |
| 解释型 | 无需编译，由解释器逐行解析源码并执行                  | 源码 → 解释器逐行执行         | Shell、Python、JavaScript | ✅ 典型解释型  |

**关键差异**：

- 编译型：一次编译，多次运行（效率高，如 `gcc test.c -o test` 生成可执行文件 `test`）；
- 解释型：每次运行都需解释器（灵活，修改源码后直接运行，无需重新编译）。

###### 1.1.1.3.1.2 按抽象层次分类

|类型|定义|特点|代表语言|Shell 归属|
|---|---|---|---|---|
|低级语言|贴近机器码，直接操作硬件|效率极高，语法晦涩|机器语言、汇编语言|❌ 不属于|
|高级语言|贴近人类自然语言，屏蔽硬件细节|易读易写，开发效率高|Shell、Python、Java|✅ 高级语言|

###### 1.1.1.3.1.3 按用途分类

|类型|定义|代表语言|Shell 归属|
|---|---|---|---|
|系统级语言|面向操作系统管理、硬件交互|C、Shell|✅ 核心用途是系统管理|
|应用级语言|面向业务开发（Web、APP、数据分析）|Python、Java、JavaScript|❌ 不适合复杂应用开发|
|脚本语言|面向自动化任务、批量处理|Shell、Perl、Python|✅ 典型脚本语言|

##### 1.1.1.3.2 配套示例（编译型 vs 解释型 对比演示）

###### 步骤 1：编译型语言（C）示例

```c
// test.c（C语言源码）
#include <stdio.h>
int main() {
    int sum = 0;
    for (int i=1; i<=10; i++) {
        sum += i;
    }
    printf("C语言计算1-10的和：%d\n", sum);
    return 0;
}
```


```bash
# 1. 编译：将C源码转化为可执行文件
gcc test.c -o test

# 2. 运行可执行文件（无需编译器，直接执行）
./test

# 3. 再次运行（无需重新编译）
./test
```

###### 步骤 2：解释型语言（Shell）示例


```bash
# test.sh（Shell源码）
#!/bin/bash
sum=0
for ((i=1; i<=10; i++)); do
    sum=$((sum + i))
done
echo "Shell计算1-10的和：$sum"
```


```bash
# 1. 运行（无需编译，Bash解释器逐行执行）
bash test.sh

# 2. 修改源码（比如计算1-20的和），直接重新运行
sed -i 's/10/20/' test.sh
bash test.sh
```

###### 步骤 3：核心差异总结


```bash
#!/bin/bash
# 对比编译型和解释型的执行效率
echo "=== 编译型（C）执行1000次 ==="
time for ((i=1; i<=1000; i++)); do ./test; done > /dev/null

echo -e "\n=== 解释型（Shell）执行1000次 ==="
time for ((i=1; i<=1000; i++)); do bash test.sh; done > /dev/null

# 输出结论
echo -e "\n结论：编译型语言执行效率更高，但解释型语言（Shell）开发/修改更灵活，适合快速自动化场景"
```

### 1.1.2 编程语言逻辑

#### 1.1.2.1 语言分类

语言分类
```powershell
低级编程语言：
机器：
	二进制的0和1的序列，称为机器指令。
	一般人看不懂
汇编：
	用一些助记符号替代机器指令，称为汇编语言。
	一般人看不懂，但是能够有感觉

高级编程语言：
	编译：
		借助于专属编译器将一些高级语言编译成机器代码文件，然后再交给程序去执行。
		如：C，C++ 等
	解释：
		将高级语言的代码逐行加载到解释器环境，逐行解释为机器代码，然后再交给程序去执行。
		如：shell，python，php，JavaScript等
```
#### 1.1.2.2 编程逻辑
```ini
shell 脚本 = Linux 命令 + 逻辑
编程语言的目的是通过风格化的编程思路将代码写出来后，实现项目功能的。为了实现功能，我们通过在代码层面通过一些代码逻辑来实现：

顺序执行 - 程序按从上到下顺序执行

选择执行 - 程序执行过程中，根据条件选择不同的顺序执行

循环执行 - 程序执行过程中，根据条件重复执行代码
```

![](assets/Shell%20编程/file-20251204142415093.png)

## 1.2 shell基础

### 1.2.1 shell简介

#### 1.2.1.1 运维是干什么的

简介
![](assets/Shell%20编程/file-20251204143149448.png)

```ini
运维是什么？
所谓的运维，其实就是公司的内部项目当中的一个技术岗位而已，它主要做的是项目的维护性工作。它所涉及的内容范围非常多。

以xx项目为例：

规划：我们需要多少资源来支持项目的运行
管理：项目运行过程中的所有内容都管理起来
流程规范：所有操作都形成制度，提高工作效率
平台：大幅度提高工作效率
监控：实时查看项目运行状态指标
告警：状态指标异常，告知工作人员处理
安全：网站运营安全措施
优化：保证用户访问网站体验很好
考核：权责分配，保证利益

自动化运维：就是将图里面所有的工作都使用自动化的方式来实现。
实现自动化的方式很多，常见的方式：工具和脚本。
工作中常见的脚本有哪些呢？
   shell脚本 和 其他开发语言脚本
```
#### 1.2.1.2 shell语言
![](assets/Shell%20编程/file-20251204143418548.png)
```bash
在计算机科学中，Shell 就是一个命令解释器。

shell 是位于操作系统和应用程序之间，是他们二者最主要的接口，shell 负责把应用程序的输入命令信息解释给操作系统，将操作系统指令处理后的结果解释给应用程序。

一句话，shell 就是在操作系统和应用程序之间的一个命令翻译工具。
```

### 1.2.2 shell 脚本实践

#### 1.2.2.1 脚本基础

shell 脚本
```bash
当可执行的 Linux 命令或语句不在命令行状态下执行，而是通过一个文件执行时，我们称文件为 shell 脚本。

重复化、复杂化的工作，通过把工作的命令写成脚本，以后仅仅需要执行脚本就能完成这些工作。
	自动化分析处理
	自动化备份
	自动化批量部署安装
	等等...
```
#### 1.2.2.2 脚本操作

脚本创建
```bash
脚本创建工具：
创建脚本的常见编辑器是 vi/vim.

脚本命名
shell脚本的命名简单来说就是要有意义，方便我们通过脚本名，来知道这个文件是干什么用的。

脚本内容：
各种可以执行的命令
```

#### 1.2.2.3 脚本实践
```bash
15:14:38 root@redis01:~# cat net_info.sh
# ==============================================================================
# 脚本基础信息
# filename: net_info.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 获取ip地址信息
ifconfig ens33 | grep -w inet | awk '{print $2}' | xargs echo "IP: "
# 获取掩码地址信息
ifconfig ens33 | grep -w inet | awk '{print $4}' | xargs echo "NetMask: "
# 获取广播地址信息
ifconfig ens33 | grep -w inet | awk '{print $6}' | xargs echo "Broadcast: "
# 获取 MAC 地址信息
ifconfig ens33 | grep ether | awk '{print $2}' |xargs echo "MAC Address: "

# 执行脚本
15:14:40 root@redis01:~# bash net_info.sh
IP:  192.168.121.131
NetMask:  255.255.255.0
Broadcast:  192.168.121.255
MAC Address:  00:0c:29:b4:8d:6a
15:14:43 root@redis01:~#
```
### 1.2.3 脚本注释
注释是 Shell 脚本中对代码逻辑、功能的说明，解释器会忽略注释内容，核心作用是提升脚本可读性、便于维护。Shell 本身仅原生支持**单行注释**，多行注释需通过特殊语法模拟
#### 1.2.3.1 单行注释（核心语法）

##### 1.2.3.1.1 知识点

1. **基本语法**：以 `#` 开头，`#` 后的所有内容均为注释（行内注释需注意位置）；
2. **注意事项**：
    - `#` 必须是行首（或行内非字符串区域），若在字符串（单 / 双引号）内，`#` 会被视为普通字符；
    - `#` 与注释内容间建议加空格（规范，非强制）；
    - 脚本首行的 `#!/bin/bash` 不是注释（Shebang，指定解释器），但 `#!` 仅在第一行有效，第二行及以后的 `#!` 会被视为注释。

##### 1.2.3.1.2 配套代码示例（single_comment.sh）

```bash
#!/bin/bash
# 这是单行注释：脚本功能 - 演示单行注释的各种写法
# 作者：xxx
# 创建时间：2025-12-04

name="Shell"  # 行内注释：定义变量（注意#前加空格，规范写法）
echo "Hello $name"  # 输出变量值

# 错误示例：字符串内的#不是注释
str="注释测试：# 这不是注释"
echo $str  # 输出：注释测试：# 这不是注释

#! 第二行的#!会被视为注释
# 注释可以写TODO：TODO 后续优化变量命名规范
```

#### 1.2.3.2 多行注释（模拟实现）

Shell 无原生多行注释语法，需通过 **空命令 `:`** + **Here Document（HereDoc）** 模拟，以下是 3 种常用方式（推荐第一种）。

##### 1.2.3.2.1 方式 1：`:<<标记符 注释内容 标记符`（最常用）

###### 1.2.3.2.1.1 知识点

- `:` 是 Shell 空命令（执行后无操作，返回值 0）；
- `<<标记符` 表示开始读取内容，直到遇到相同的`标记符`结束（标记符可自定义，如 EOF、!、_ 等）；
- 注释内容中可包含任意字符（包括 #、特殊符号），标记符必须成对且结束标记符需单独一行（无空格）。

###### 1.2.3.2.1.2 配套代码示例（multi_comment1.sh）

```bash
#!/bin/bash
# 演示多行注释（推荐方式）
:<<EOF
这是多行注释块：
1. 脚本用途：批量处理日志文件
2. 核心逻辑：
   - 遍历 /var/log 下的 .log 文件
   - 压缩7天前的日志
   - 删除30天前的日志
3. 注意事项：执行前需确认日志目录权限
EOF

# 业务代码
echo "开始处理日志..."
```

##### 1.2.3.2.2 方式 2：`: 加单行注释堆叠（简单但不优雅）`

###### 1.2.3.2.2.1 知识点

- 每行都以 `#` 开头，适合短注释块；
- 优点：简单直观；缺点：注释 / 取消注释需逐行操作。

###### 1.2.3.2.2.2 配套代码示例（multi_comment2.sh）

```bash
#!/bin/bash
# 多行注释（堆叠式）
# 功能：计算1-100的和
# 实现逻辑：
# 1. 初始化sum=0
# 2. for循环遍历1-100
# 3. 累加求和并输出

sum=0
for ((i=1; i<=100; i++)); do
    sum=$((sum + i))
done
echo "1-100的和：$sum"
```

##### 1.2.3.2.3 方式 3：其他标记符变体（灵活适配场景）

###### 1.2.3.2.3.1 知识点

- 标记符可自定义（如 `!`、`_`、`COMMENT`），避免与注释内容冲突；
- 结束标记符必须**顶行写**（前后无空格、无缩进）。

###### 1.2.3.2.3.2 配套代码示例（multi_comment3.sh）

```bash
#!/bin/bash
# 自定义标记符的多行注释
:<<!
注释内容包含EOF字符：比如"备份文件到 /tmp/EOF/"
使用!作为标记符，避免冲突
!

:<<_
这是另一个多行注释块
标记符为下划线_
_

echo "自定义标记符演示完成"
```

##### 1.2.3.2.4 多行注释注意事项

1. 结束标记符必须单独一行，且**无任何空格 / 缩进**（如下写法错误）：
```bash
:<<EOF
错误示例
  EOF  # 缩进导致注释未结束，脚本报错
```
    
2. 多行注释不能嵌套（如下写法错误）：
    
```bash
    :<<EOF
    外层注释
    :<<!
    内层注释（错误：嵌套不支持）
    !
    EOF
```

    
3. 注释块内避免出现与结束标记符完全一致的内容（会提前终止注释）。

#### 1.2.3.4 注释的最佳实践（规范）

##### 1.2.3.4.1 必加注释的场景

- 脚本开头：注明功能、作者、创建时间、依赖、执行权限；
- 核心逻辑：复杂判断 / 循环、特殊算法的说明；
- 特殊参数：脚本参数的含义、默认值；
- 风险操作：删除 / 修改文件、系统配置变更的提示；
- TODO/FIXME：待优化、待修复的问题。

##### 1.2.3.4.2 规范注释示例（standard_comment.sh）

```bash
#!/bin/bash
##############################################################################
# 脚本名称：log_clean.sh
# 功能描述：自动清理/压缩系统日志，避免磁盘空间耗尽
# 作者：xxx
# 创建时间：2025-12-04
# 依赖环境：bash 4.0+、gzip、find
# 执行权限：需root用户（或sudo权限）
# 使用方式：bash log_clean.sh [日志目录] [保留天数]
#          示例：bash log_clean.sh /var/log 30
##############################################################################

# 定义默认参数
LOG_DIR=${1:-/var/log}  # 参数1：日志目录，默认/var/log
KEEP_DAYS=${2:-30}      # 参数2：保留天数，默认30天

# 校验参数合法性（核心逻辑注释）
if ! [[ $KEEP_DAYS =~ ^[0-9]+$ ]]; then
    echo "错误：保留天数必须是数字！"
    exit 1
fi

# 压缩7天前的日志（风险操作：需确认文件存在）
find $LOG_DIR -name "*.log" -mtime +7 -exec gzip {} \;

# FIXME：后续需添加日志压缩后的备份逻辑
# TODO：增加邮件通知功能，清理完成后发送报告

echo "日志清理完成！保留最近${KEEP_DAYS}天的日志"
```

#### 1.2.3.5 注释常见误区
1. 注释与代码脱节：代码修改后未同步更新注释（导致注释误导）；
2. 过度注释：简单逻辑（如 `i=1`）无需注释，避免冗余；
3. 注释内容模糊：如仅写 “处理数据”，应明确 “处理 /var/log 下的日志数据，过滤空行”；
4. 行内注释滥用：行尾仅注释关键逻辑，避免每行都加行内注释。

### 1.2.4 脚本执行方式
#### 1.2.4.1 核心概念铺垫
在讲解执行方式前，先明确两个关键概念：

1. **子 Shell**：执行脚本时新建的 Shell 进程，子 Shell 的环境变量 / 修改不会同步到父 Shell；
2. **执行权限**：脚本文件需具备`x`（执行）权限（`chmod +x`），部分方式可绕过；
3. **当前 Shell 环境**：终端当前的进程环境（如已定义的变量、别名等）。

#### 1.2.4.2 方式一：直接执行（赋予执行权限后运行）
##### 1.2.4.2.1 核心语法
```bash
# 步骤1：赋予执行权限（仅需执行一次）
chmod +x 脚本名.sh

# 步骤2：执行（需指定路径，相对/绝对均可）
./脚本名.sh        # 相对路径（当前目录）
/绝对路径/脚本名.sh # 绝对路径（如 /root/scripts/test.sh）
```

##### 1.2.4.2.2 案例
```bash
15:57:37 root@redis01:~# cat test01.sh
# ==============================================================================
# 脚本基础信息
# filename: test01.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 演示直接执行的特点
export TEST_VAR="直接执行-子Shell变量"
echo "脚本内的TEST_VAR：$TEST_VAR"
echo "当前Shell进程ID（PID）：$$" # $$表示当前进程ID

15:57:39 root@redis01:~# chmod +x test01.sh
15:57:54 root@redis01:~# ls -l test01.sh
-rwxr-xr-x 1 root root 486 Dec  4 15:57 test01.sh

# 直接执行（相对路径）
# 输出示例：
# 脚本内的TEST_VAR：直接执行-子Shell变量
# 当前Shell进程ID（PID）：12345（随机数，与终端PID不同）
15:57:59 root@redis01:~# ./test01.sh 
脚本内的TEST_VAR：直接执行-子Shell变量
当前Shell进程ID（PID）：17051

# 验证是否修改当前 Shell 环境
# 输出：终端的TEST_VAR：（空，子 Shell 变量不回传）
15:58:06 root@redis01:~# echo "终端的TEST_VAR：$TEST_VAR"
终端的TEST_VAR：
15:58:42 root@redis01:~# 

```

##### 1.2.4.2.3 适用场景
- 生产环境中独立运行的脚本（如自动化部署、日志清理、定时任务核心脚本）；
- 脚本需要作为可执行程序独立分发 / 运行；
- 希望脚本在子 Shell 中运行，避免污染当前终端环境（如修改环境变量、定义函数）。
##### 1.2.4.2.4 注意事项
- 必须指定路径（`./`或绝对路径），否则系统会在`$PATH`中查找，若当前目录不在`$PATH`则报错（如直接输`exec_direct.sh`会提示 “命令未找到”）；
- 脚本首行`#!/bin/bash`（Shebang）必须正确，否则可能执行失败（如指定不存在的解释器`#!/bin/xxx`）；
- 执行权限仅需赋予一次，后续可重复执行。
#### 1.2.4.3 方式二：通过解释器直接执行（bash/sh 脚本.sh）
##### 1.2.4.3.1 核心语法
```bash
bash 脚本名.sh [参数]  # 使用Bash解释器（推荐）
sh 脚本名.sh [参数]    # 使用sh解释器（兼容模式）
zsh 脚本名.sh [参数]   # 其他Shell解释器（如zsh/ksh）
```

##### 1.2.4.3.2 配套案例
```bash
16:06:05 root@redis01:~# cat test02.sh 
# ==============================================================================
# 脚本基础信息
# filename: test02.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 演示解释器执行的特点
echo "使用的解释器：$SHELL"
echo "脚本参数1：$1"  # 接收命令行参数
export INTERP_VAR="解释器执行-子Shell变量"
echo "脚本内的INTERP_VAR：$INTERP_VAR"


# 1. 无需赋予执行权限，直接用bash执行（传参）
bash exec_interpreter.sh 测试参数
# 输出示例：
# 使用的解释器：/bin/bash
# 脚本参数1：测试参数
# 脚本内的INTERP_VAR：解释器执行-子Shell变量

# 2. 验证当前Shell环境（变量未同步）
echo "终端的INTERP_VAR：$INTERP_VAR"
# 输出：终端的INTERP_VAR：（空）

# 3. 用sh执行（兼容模式，注意Bash扩展语法可能报错）
sh exec_interpreter.sh
# 若脚本含[[ ]]、C风格for循环等Bash扩展语法，sh执行会报错
```

##### 1.2.4.3.3 适用场景
- 脚本未赋予执行权限（如临时测试、只读文件、共享目录下的脚本）；
- 需要指定特定解释器运行（如用`sh`兼容模式验证脚本跨 Shell 兼容性）；
- 开发 / 调试阶段快速测试脚本，无需频繁修改权限。
##### 1.2.4.3.4 注意事项
- 无需执行权限，但脚本文件需有**读权限**（`r`）（如`chmod 400 脚本.sh`仍可执行）；
- 若脚本首行 Shebang 与执行时指定的解释器冲突，以执行时指定的为准（如 Shebang 是`#!/bin/sh`，但用`bash`执行则用 Bash）；
- `sh`是 Bash 的兼容模式，部分 Bash 扩展语法（如`[[ ]]`、`for ((i=1; i<=10; i++))`）在`sh`下会报错。
#### 1.2.4.3 方式三：source / 点命令执行（source 脚本.sh/. 脚本.sh）
##### 1.2.4.3.1 核心语法
```bash
source 脚本名.sh [参数]  # 方式1（直观）
. 脚本名.sh [参数]       # 方式2（点+空格+脚本名，空格不可省略）
```
##### 1.2.4.3.2 配套案例
```bash
16:09:50 root@redis01:~# cat test03.sh
# ==============================================================================
# 脚本基础信息
# filename: test03.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 演示source执行的特点
export SOURCE_VAR="source执行-当前Shell变量"
echo "脚本内的SOURCE_VAR：$SOURCE_VAR"
echo "当前Shell进程ID（PID）：$$" # 与终端PID一致

# 定义一个函数（仅当前Shell有效）
hello() {
    echo "Hello from source script! 参数：$1"
}


# 1. 无需执行权限，source执行（传参）
source test03.sh 测试参数
# 输出示例：
# 脚本内的SOURCE_VAR：source执行-当前Shell变量
# 当前Shell进程ID（PID）：6789（与终端PID相同）

# 2. 验证当前Shell环境（变量已生效）
echo "终端的SOURCE_VAR：$SOURCE_VAR"
# 输出：终端的SOURCE_VAR：source执行-当前Shell变量

# 3. 调用脚本内定义的函数（已生效）
hello 世界
# 输出：Hello from source script! 参数：世界

# 4. 用点命令执行（等价source）
. exec_source.sh
```

##### 1.2.4.3.3 适用场景

- 需要修改当前 Shell 环境的场景（如定义环境变量、别名、函数）；
- 加载系统 / 项目配置文件（如`source ~/.bashrc`、`source /etc/profile`）；
- 脚本中的变量 / 函数需要在终端后续操作中使用（如项目启动前的环境配置）；
- 批量设置环境变量（如`export PATH=/usr/local/bin:$PATH`）。
##### 1.2.4.3.4 注意事项

- 不创建子 Shell，脚本的所有修改（变量、函数、别名）都会直接影响当前终端；
- 无需执行权限，但需读权限；
- 脚本中的`exit`命令会直接退出当前终端（而非仅退出脚本），需慎用；
- 路径规则：若脚本不在当前目录，需指定相对 / 绝对路径（如`source ../config.sh`）
#### 1.2.4.4 方式四：重定向执行（sh < 脚本.sh）
##### 1.2.4.4.1 核心语法
```bash
bash < 脚本名.sh [参数]  # Bash解释器
sh < 脚本名.sh [参数]    # sh解释器

# 扩展：远程脚本管道执行（最常用场景）
curl -s http://example.com/remote.sh | bash
```

##### 1.2.4.4.2 配套案例
```bash
#!/bin/bash
# 演示重定向执行的特点
echo "重定向执行-脚本参数1：$1"  # 注意：参数无法传递！
export REDIRECT_VAR="重定向执行-子Shell变量"
echo "脚本内的REDIRECT_VAR：$REDIRECT_VAR"


# 1. 重定向执行（尝试传参，无效）
bash < exec_redirect.sh 测试参数
# 输出：
# 重定向执行-脚本参数1：（空，参数无法传递）
# 脚本内的REDIRECT_VAR：重定向执行-子Shell变量

# 2. 验证当前环境（变量未同步）
echo "终端的REDIRECT_VAR：$REDIRECT_VAR"
# 输出：终端的REDIRECT_VAR：（空）

# 3. 远程脚本管道执行（示例，仅演示语法）
# curl -s https://raw.githubusercontent.com/xxx/test.sh | bash
```

##### 1.2.4.4.3 适用场景
- 脚本文件来自标准输入（如远程下载后直接执行、管道传输的脚本内容）；
- 临时执行无本地文件的脚本（如快速测试网上的脚本片段）；
- 自动化部署中 “一键执行” 远程脚本（如`curl | bash`）。

##### 1.2.4.4.4 注意事项
- 无法向脚本传递命令行参数（`$1`、`$2`等为空）；
- 创建子 Shell，不修改当前环境；
- 脚本首行的 Shebang 会被忽略（解释器由执行时指定的`bash/sh`决定）；
- 风险提示：远程脚本管道执行（`curl | bash`）需确认脚本来源安全，避免执行恶意代码
#### 1.2.4.5 方式五：作为函数/别名执行
##### 1.2.4.5.1 核心语法
```bash
# 方式1：将脚本内容封装为函数（当前Shell生效）
function 函数名() {
    # 原脚本核心逻辑
}

# 方式2：别名执行（简化长命令）
alias 别名="bash /绝对路径/脚本名.sh [固定参数]"
```

##### 1.2.4.5.2 配套案例
```bash
#!/bin/bash
# 定义函数（替代独立脚本文件）
log_clean() {
    # 核心逻辑：清理7天前的日志文件
    find /var/log -name "*.log" -mtime +7 -delete
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] 日志清理完成！"
}

# 执行函数（当前Shell生效）
log_clean

# 后续终端可重复调用
# log_clean
```

```bash
# 1. 定义临时别名（终端关闭后失效）
alias clean_log="bash /root/scripts/log_clean.sh"

# 2. 执行别名
clean_log

# 3. 永久生效：将别名写入~/.bashrc
echo "alias clean_log='bash /root/scripts/log_clean.sh'" >> ~/.bashrc
source ~/.bashrc  # 立即生效（无需重启终端）
```
##### 1.2.4.5.3 适用场景
- 脚本逻辑需要频繁复用（如日常运维命令：日志清理、服务重启）；
- 简化长路径 / 复杂参数的脚本执行（如`alias deploy='bash /data/project/deploy.sh prod'`）；
- 脚本逻辑较短，无需单独文件存储（如几行的小工具）。
##### 1.2.4.5.4 注意事项
- 函数执行在当前 Shell 环境（类似 source），变量 / 修改会影响当前终端；
- 别名本质是 “解释器执行” 的封装，创建子 Shell，不修改当前环境；
- 永久别名需写入`~/.bashrc`（普通用户）或`/etc/bashrc`（全局），并 source 生效；
- 别名若与系统命令重名，需用`\命令名`执行原生命令（如`\ls`跳过 ls 别名）。
#### 1.2.4.6 方式六：定时执行（crontab）
##### 1.2.4.6.1 核心语法
```bash
# 步骤1：编辑crontab定时任务
crontab -e

# 步骤2：添加定时规则（分 时 日 月 周 执行命令）
*/30 * * * * bash /绝对路径/脚本名.sh > /tmp/脚本日志.log 2>&1
```
#### 1.2.4.7 各执行方式对比 & 选型建议
|执行方式|是否需执行权限|是否创建子 Shell|是否修改当前环境|能否传参|核心适用场景|
|---|---|---|---|---|---|
|直接执行（./ 脚本.sh）|是|是|否|能|独立运行的生产脚本|
|解释器执行（bash 脚本）|否|是|否|能|临时测试、指定解释器|
|source / 点命令|否|否|是|能|加载配置、修改当前环境|
|重定向执行（bash < 脚本）|否|是|否|否|远程脚本、标准输入执行|
|函数 / 别名执行|无（无文件）|函数：否 / 别名：是|函数：是 / 别名：否|能|频繁复用、简化命令|
|crontab 定时执行|建议是|是|否|能|周期性后台任务|
选型核心原则

1. 若需修改当前环境（变量 / 函数 / 别名）→ 选 `source`/ 函数执行；
2. 若独立运行、不污染环境 → 选 直接执行 / 解释器执行；
3. 若远程 / 无文件执行 → 选 重定向执行（`curl | bash`）；
4. 若周期性任务 → 选 crontab 定时执行；
5. 若频繁复用 → 选 函数 / 别名执行。

### 1.2.5 脚本调试方式
Shell 脚本调试的核心目标是定位**语法错误**、**逻辑错误**、**变量值异常**、**命令执行失败**等问题。根据脚本复杂度和调试需求，可分为「解释器级调试（bash 内置参数）」「脚本内精细化调试」「实战技巧 / 第三方工具」三类
#### 1.2.5.1 核心概念
1. **语法错误**：违反 Shell 语法规则（如少写 `done`、括号不匹配），脚本直接无法执行；
2. **逻辑错误**：语法合法但结果不符合预期（如循环次数错误、变量值为空）；
3. **调试输出**：通过打印命令、变量、执行流程，还原脚本运行过程；
4. **静态检查**：不执行脚本，提前检测语法 / 规范 / 潜在问题。
#### 1.2.5.2 方式 1：bash 内置调试参数（最常用）
bash 提供了一系列内置参数，可直接通过命令行传递，快速开启调试模式，无需修改脚本内容。

|参数|核心作用|语法示例|适用场景|
|---|---|---|---|
|`-n`|检查语法错误，**不执行脚本**|`bash -n script.sh`|快速验证脚本语法合法性（如写完脚本第一步检查）|
|`-x`|跟踪执行过程，打印每一步命令（展开变量）|`bash -x script.sh`|定位逻辑错误（如变量值异常、循环 / 判断逻辑错误）|
|`-v`|打印脚本原始内容 + 执行过程（不展开变量）|`bash -v script.sh`|确认脚本是否被正确读取（如路径 / 编码问题）|
|`-e`|任意命令执行失败（返回值≠0）立即退出脚本|`bash -e script.sh`|避免错误扩散（如某步命令失败后，脚本仍继续执行导致更多问题）|
|`-u`|使用**未定义变量**时立即报错|`bash -u script.sh`|定位因变量未定义 / 为空导致的逻辑错误|
|`-o xtrace`|等价 `-x`，可结合其他参数（如 `-o errexit` 等价 `-e`）|`bash -o xtrace -o errexit script.sh`|多参数组合调试|

##### 1.2.5.2.1 基础参数案例（单参数调试）
###### 1.2.5.2.1.1 -n 检查语法错误
```bash
16:31:30 root@redis01:~# cat test1.sh
# ==============================================================================
# 脚本基础信息
# filename: test1.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 语法错误：for循环缺少done
sum=0
for ((i=1; i<=10; i++)) {
    sum=$((sum + i))
# 缺少done
echo "1-10的和：$sum"

16:31:31 root@redis01:~# bash -n test1.sh 
# 输出报错（定位语法错误行）：
test1.sh: line 17: syntax error: unexpected end of file
16:31:36 root@redis01:~# 

```
###### 1.2.5.2.1.2 -x 跟踪执行过程⭐⭐⭐
```bash
16:33:30 root@redis01:~# cat debug.sh
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 计算1-10的偶数和
sum=0
for ((i=1; i<=10; i++)); do
    if ((i % 2 == 0)); then
        sum=$((sum + i))
    fi
done
echo "1-10偶数和：$sum"

# 执行调试（-x 会打印每一步执行的命令和变量值）：
16:33:33 root@redis01:~# bash -x debug.sh 
+ sum=0
+ (( i=1 ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ sum=2
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ sum=6
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ sum=12
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ sum=20
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ (( i++ ))
+ (( i<=10 ))
+ (( i % 2 == 0 ))
+ sum=30
+ (( i++ ))
+ (( i<=10 ))
+ echo 1-10偶数和：30
1-10偶数和：30

```
**关键**：通过 `-x` 可清晰看到循环次数、变量 `i` 和 `sum` 的变化，快速定位逻辑错误（如循环条件写错、判断条件错误）。

###### 1.2.5.2.1.3 -e 命令失败立即退出
```bash
16:35:13 root@redis01:~# cat debug.sh
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 演示-e参数：执行错误命令后立即退出
ls /xxx  # 不存在的目录，执行失败
echo "这行不会执行"  # 因-e参数，上一步失败后脚本直接退出
16:35:14 root@redis01:~# bash -e debug.sh 
# 输出：
# ls: 无法访问'/xxx': 没有那个文件或目录
# （无后续echo输出，脚本已退出）
ls: cannot access '/xxx': No such file or directory
16:35:18 root@redis01:~#
```
###### 1.2.5.2.1.4 -u 未定义变量报错
```bash
16:36:38 root@redis01:~# cat debug.sh
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 演示-u参数：使用未定义变量
echo "未定义变量：$undefined_var"
echo "这行不会执行"

16:36:39 root@redis01:~# bash -u debug.sh
debug.sh: line 11: undefined_var: unbound variable
16:36:44 root@redis01:~# 

```
##### 1.2.5.2.2 组合参数调试
多个参数组合可覆盖更多调试场景，比如：
```bash
# 组合：语法检查(-n) + 执行失败退出(-e) + 未定义变量报错(-u) + 跟踪执行(-x)
bash -n -e -u -x script.sh

# 等价简写（-o 方式）
bash -o errexit -o nounset -o xtrace script.sh
```

#### 1.2.5.3 方式 2：脚本内精细化调试（set 指令）
当脚本较长时，全局 `-x` 会输出大量日志，可通过 `set` 指令在脚本内**局部开启 / 关闭调试**，只调试关键代码段。
##### 1.2.5.3.1 核心语法
```bash
set -x  # 开启调试（等价bash -x）
set +x  # 关闭调试
set -e  # 开启“命令失败立即退出”
set +e  # 关闭“命令失败立即退出”
set -u  # 开启“未定义变量报错”
set +u  # 关闭“未定义变量报错”
```
##### 1.2.5.3.2 配套案例
```bash
16:40:24 root@redis01:~# cat debug.sh
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 脚本内局部调试示例
echo "这部分不调试"

# 开启调试（只调试循环部分）
set -x
sum=0
for ((i=1; i<=5; i++)); do
    sum=$((sum + i))
done
set +x  # 关闭调试

echo "调试结束，总和：$sum"
echo "这部分也不调试"

16:40:25 root@redis01:~# bash debug.sh
这部分不调试
+ sum=0
+ (( i=1 ))
+ (( i<=5 ))
+ sum=1
+ (( i++ ))
+ (( i<=5 ))
+ sum=3
+ (( i++ ))
+ (( i<=5 ))
+ sum=6
+ (( i++ ))
+ (( i<=5 ))
+ sum=10
+ (( i++ ))
+ (( i<=5 ))
+ sum=15
+ (( i++ ))
+ (( i<=5 ))
+ set +x
调试结束，总和：15
这部分也不调试

```
##### 1.2.5.3.3 进阶：自定义调试输出格式
通过 `PS4` 变量可自定义 `-x` 的调试前缀，显示行号、函数名等，便于定位问题：
```bash
16:41:46 root@redis01:~# cat debug.sh 
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 自定义调试输出格式：显示行号+命令
export PS4='[行号:$LINENO] '
set -x

sum=0
for ((i=1; i<=3; i++)); do
    sum=$((sum + i))
done
set +x

echo "总和：$sum"
16:41:48 root@redis01:~# bash debug.sh
[行号:14] sum=0
[行号:15] (( i=1 ))
[行号:15] (( i<=3 ))
[行号:16] sum=1
[行号:15] (( i++ ))
[行号:15] (( i<=3 ))
[行号:16] sum=3
[行号:15] (( i++ ))
[行号:15] (( i<=3 ))
[行号:16] sum=6
[行号:15] (( i++ ))
[行号:15] (( i<=3 ))
[行号:18] set +x
总和：6

```

#### 1.2.5.4 方式 3：实战调试技巧（低成本高效）
对于复杂脚本，结合以下技巧可快速定位问题，无需依赖复杂工具。

##### 1.2.5.4.1 关键位置打印变量 / 状态

在脚本的判断、循环、函数前后，手动添加 `echo`/`printf` 打印变量值、命令返回值，是最基础且有效的调试方式。

```bash
16:44:03 root@redis01:~# cat debug.sh 
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 手动打印变量调试
read -p "请输入数字：" num

# 打印输入的变量值（验证是否正确接收）
echo "【调试】输入的num值：$num，类型：$(file -b <(echo $num))"

# 校验是否为数字
if ! [[ $num =~ ^[0-9]+$ ]]; then
    echo "错误：输入不是数字"
    exit 1
fi

# 打印计算过程
sum=$((num * 2))
echo "【调试】num*2的结果：$sum"

echo "最终结果：$sum"
16:44:06 root@redis01:~# bash debug.sh
请输入数字：4
【调试】输入的num值：4，类型：symbolic link to pipe:[96197]
【调试】num*2的结果：8
最终结果：8
16:44:10 root@redis01:~#
```
##### 1.2.5.4.2 捕获错误信号 trap
通过 `trap` 捕获脚本执行中的错误（`ERR` 信号），自动打印出错行、变量值，无需手动加 `echo`。
###### 1.2.5.4.2.1 trap 测试
```bash
16:51:41 root@redis01:~# cat debug.sh 
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 捕获ERR信号，打印出错信息
trap 'echo "【错误】行号$LINENO执行失败！当前变量：num=$num"; exit 1' ERR

num="abc"  # 非数字，导致后续计算失败
((sum = num * 2))  # 这行会触发ERR信号
echo "不会执行到这里"

16:51:42 root@redis01:~# bash debug.sh 
【错误】行号14执行失败！当前变量：num=abc
16:51:43 root@redis01:~#
```

###### 1.2.5.4.2.2 ERR 信号触发规则
`ERR` 信号仅在 **“简单命令” 执行失败（返回值≠0）** 时触发，而 `$((...))` 属于「参数扩展」（不是独立的 “简单命令”），其内部语法错误不会改变整个命令的返回码，也不会触发 `ERR`。

|语法类型|是否为 “简单命令”|错误是否返回非 0|是否触发 ERR|
|---|---|---|---|
|`$((num*2))`（算术扩展）|否（参数扩展）|否（脚本继续执行）|❌ 不触发|
|`let num*2`（let 命令）|是（独立命令）|是（返回非 0）|✅ 触发|
|`((num*2))`（算术命令）|是（独立命令）|是（返回非 0）|✅ 触发|
```bash
16:55:57 root@redis01:~# cat debug.sh 
# ==============================================================================
# 脚本基础信息
# filename: debug.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
num="a"
# 1. 算术扩展：错误但返回码为0
sum=$((num*2))
echo $?

# 2. let 命令：错误且返回码非0
let sum=sum*2
echo $?

# 3. 算术命令：错误且返回码非0
((sum = sum * 2))
echo $?
16:55:59 root@redis01:~# bash debug.sh 
0
1
1

```
###### 1.2.5.4.2.3 ERR 信号的其他触发注意事项
即使使用了 “简单命令”，以下场景也可能导致 `ERR` 信号不触发，需额外注意：
- 错误命令在 if/while/until 条件中
- 未开启 set -o errexit（或 set -e）
	- `ERR` 信号的触发不依赖 `set -e`，但 `set -e` 会让脚本在命令失败时立即退出，与 `trap ERR` 结合更稳妥
- 管道命令的失败（默认只检测最后一个命令）
	- 管道中前面的命令失败，默认不会触发 `ERR`（如 `ls /xxx | grep a`，`ls` 失败但 `grep` 成功，整体返回码为 0）：
##### 1.2.5.4.3 重定向调试输出到文件
当 `-x` 输出过多时，可将调试日志重定向到文件，避免终端刷屏，便于后续分析。
```bash
# 方式1：命令行重定向
bash -x debug_x.sh > debug.log 2>&1

# 方式2：脚本内重定向（仅调试输出到文件）
#!/bin/bash
exec 2> debug.log  # 将标准错误（-x 的调试输出）重定向到文件
set -x
sum=0
for ((i=1; i<=10; i++)); do
    sum=$((sum + i))
done
set +x
echo "总和：$sum"
```
#### 1.2.5.5 方式 4：第三方工具调试（复杂脚本）
对于逻辑复杂的脚本（如多函数、多分支、嵌套循环），可使用专业调试工具。

##### 1.2.5.5.1 shellcheck：静态语法 / 规范检查（推荐）

###### 1.2.5.5.1.1 作用

检测脚本中的语法错误、潜在问题（如未定义变量、无用代码、不符合规范的写法），给出修复建议。

###### 1.2.5.5.1.2 安装（Linux）
```bash
# CentOS/RHEL
yum install -y shellcheck

# Ubuntu/Debian
apt update
apt install -y shellcheck

# macOS
brew install shellcheck
```
###### 1.2.5.5.1.3 案例（检测脚本问题）

准备有问题的脚本
```bash
#!/bin/bash
# 存在的问题：未定义变量、无用的cd命令、双引号缺失
cd /tmp
echo $undefined_var
ls $HOME/*.log  # 无双引号，若文件名含空格会出错

shellcheck bad_script.sh
# 输出示例（给出问题和修复建议）：
# In bad_script.sh line 5:
# echo $undefined_var
#      ^-----------^ SC2154: undefined_var is referenced but not assigned.
#
# In bad_script.sh line 4:
# cd /tmp
# ^-- SC2164: Use 'cd ... || exit' or 'cd ... || return' in case cd fails.
#
# In bad_script.sh line 6:
# ls $HOME/*.log
#    ^----------^ SC2086: Double quote to prevent globbing and word splitting.
```
#### 1.2.5.6 总结
| 调试场景                 | 推荐方式                        | 核心优势             |
| -------------------- | --------------------------- | ---------------- |
| 快速检查语法错误             | `bash -n` + `shellcheck`    | 不执行脚本，快速定位语法问题   |
| 定位逻辑错误（变量 / 循环 / 判断） | `bash -x` + 脚本内 `set -x/+x` | 跟踪执行过程，还原变量变化    |
| 避免错误扩散               | `bash -e` + `trap ERR`      | 出错立即退出，自动打印错误信息  |
| 变量相关问题               | `bash -u` + 手动 `echo` 变量    | 定位未定义 / 空变量导致的问题 |
| 复杂脚本（多函数 / 分支）       | `bashdb` 断点调试               | 精细化控制执行流程，查看调用栈  |
| 规范 / 潜在问题            | `shellcheck`                | 给出修复建议，提升脚本健壮性   |

#### 1.2.5.7 调试最佳实践
1. **先静态后动态**：先用 `bash -n` + `shellcheck` 检查语法 / 规范，再用 `-x` 跟踪执行；
2. **局部调试**：长脚本用 `set -x/+x` 只调试关键段，避免日志冗余；
3. **关键节点打印**：在判断、循环、函数前后打印变量 / 状态，快速定位问题；
4. **重定向调试日志**：复杂脚本将 `-x` 输出重定向到文件，便于复盘；
5. **避免调试残留**：调试完成后，删除 / 注释掉脚本内的 `set -x`、`echo` 等调试代码；
6. **结合返回值**：通过 `echo $?` 打印命令返回值，定位命令执行失败的原因（如 `ls /xxx; echo $?`）。
### 1.2.6 脚本开发规范
**工业级标准：可维护 + 可扩展 + 安全**
#### 1.2.6.1 基础规范
##### 1.2.6.1.1 Shebang 规范
- **规则**：
    1. Shebang（`#!/bin/bash`）必须是脚本**第一行**，行首无任何空格 / 制表符 / 空行 / 注释；
    2. 明确指定解释器（优先用 `#!/bin/bash`，而非 `#!/bin/sh`，避免兼容问题）；
    3. 禁止在 Shebang 行尾加注释（ShellCheck 会报 SC1015 警告）。

##### 1.2.6.1.2 文件名规范
- **强制规则**：
    1. 小写字母 + 下划线（`_`）组合，禁止大写 / 空格 / 特殊字符（如 `-` 尽量避免，易与参数混淆）；
    2. 后缀统一为 `.sh`（便于识别，非强制但推荐）；
    3. 命名体现脚本功能（如 `log_clean.sh` 而非 `test1.sh`）；
    4. 批量脚本按模块前缀分类（如 `db_backup_mysql.sh`、`db_backup_postgres.sh`）。
- **正确示例**：`system_monitor.sh`、`file_batch_rename.sh`
- **错误示例**：`SystemMonitor.sh`、`文件备份.sh`、`test.sh`
##### 1.2.6.1.3 文件权限规范
- **强制规则**：
    1. 执行脚本权限设为 `755`（`chmod 755 script.sh`），普通脚本文件设为 `644`；
    2. 禁止设置 `777` 权限（任意用户可修改，极高安全风险）；
    3. 脚本所属用户 / 组明确（生产环境建议归 `root` 或专用运维用户）。
```bash
chmod 755 /usr/local/bin/log_clean.sh
chown root:root /usr/local/bin/log_clean.sh
```
##### 1.2.6.1.4 编码与换行规范
- **强制规则**：
    1. 编码统一为 `UTF-8`（避免中文注释乱码）；
    2. 换行符用 Unix 格式（`LF`），禁止 Windows 格式（`CRLF`，会导致 `\r` 语法错误）；
    3. 脚本末尾保留一个空行（符合 POSIX 规范，避免部分工具解析异常）。
```bash
# 检查换行符（CRLF会显示^M）
cat -v script.sh
# 修正为LF换行符
dos2unix script.sh
```
#### 1.2.6.2 文件结构规范（模块化，易维护）
规范的脚本需按「固定顺序」组织内容，便于快速定位逻辑。推荐结构如下：
```bash
#!/bin/bash
##############################################################################
# 1. 头部注释（脚本元信息）
##############################################################################
# 脚本名称：log_clean.sh
# 功能描述：自动清理/压缩系统日志，监控磁盘使用率
# 作者：xxx
# 创建时间：2025-12-05
# 版本：v1.2
# 依赖环境：bash 4.0+、gzip、find、df
# 执行权限：需root/sudo权限
# 使用方式：bash log_clean.sh [日志目录] [保留天数]
#          示例：bash log_clean.sh /var/log 30
# 注意事项：执行前需确认日志目录无重要临时文件
##############################################################################

##############################################################################
# 2. 环境检查（依赖/权限/系统）
##############################################################################
# 检查解释器版本
if [[ ${BASH_VERSION%%.*} -lt 4 ]]; then
    echo "错误：需要bash 4.0及以上版本"
    exit 1
fi

# 检查执行用户
if [[ $UID -ne 0 ]]; then
    echo "错误：需root用户执行"
    exit 1
fi

# 检查依赖命令
dep_commands=("gzip" "find" "df")
for cmd in "${dep_commands[@]}"; do
    if ! command -v $cmd &>/dev/null; then
        echo "错误：缺少依赖命令 $cmd，请先安装"
        exit 1
    fi
done

##############################################################################
# 3. 全局变量定义（大写+下划线，便于区分）
##############################################################################
# 默认参数
LOG_DIR=${1:-/var/log}
KEEP_DAYS=${2:-30}
LOG_FILE="/var/log/log_clean.log"
TIMESTAMP=$(date +'%Y-%m-%d %H:%M:%S')

##############################################################################
# 4. 函数定义（单一职责，命名见名知意）
##############################################################################
# 日志输出函数
log_info() {
    echo "[$TIMESTAMP] [INFO] $1" >> $LOG_FILE
    echo "[$TIMESTAMP] [INFO] $1"
}

log_error() {
    echo "[$TIMESTAMP] [ERROR] $1" >> $LOG_FILE
    echo "[$TIMESTAMP] [ERROR] $1"
    exit 1
}

# 清理日志函数
clean_old_logs() {
    log_info "开始清理日志：目录=$LOG_DIR，保留天数=$KEEP_DAYS"
    # 压缩7天前的日志
    find $LOG_DIR -name "*.log" -type f -mtime +7 -exec gzip {} \;
    if [[ $? -ne 0 ]]; then
        log_error "压缩日志失败"
    fi
    # 删除30天前的压缩日志
    find $LOG_DIR -name "*.log.gz" -type f -mtime +$KEEP_DAYS -delete
    if [[ $? -ne 0 ]]; then
        log_error "删除日志失败"
    fi
    log_info "日志清理完成"
}

# 磁盘监控函数
check_disk_usage() {
    disk_usage=$(df -h $LOG_DIR | grep -v Filesystem | awk '{print $5}' | sed 's/%//g')
    if [[ $disk_usage -gt 80 ]]; then
        log_error "磁盘使用率超标：$disk_usage%（阈值80%）"
    fi
    log_info "磁盘使用率：$disk_usage%"
}

##############################################################################
# 5. 主逻辑（调用函数，简洁清晰）
##############################################################################
main() {
    # 校验参数合法性
    if ! [[ $KEEP_DAYS =~ ^[0-9]+$ ]]; then
        log_error "保留天数必须是数字：$KEEP_DAYS"
    fi
    if ! [[ -d $LOG_DIR ]]; then
        log_error "日志目录不存在：$LOG_DIR"
    fi

    # 执行核心逻辑
    check_disk_usage
    clean_old_logs

    log_info "脚本执行完成"
    exit 0
}

# 调用主函数
main

##############################################################################
# 6. 收尾清理（可选，如临时文件删除）
##############################################################################
# trap 'rm -f /tmp/tmp.log' EXIT
```
1. 头部注释：必须包含「功能、作者、版本、依赖、使用方式」，便于他人快速理解；
2. 环境检查：先校验依赖 / 权限 / 参数，避免脚本执行中报错；
3. 变量 / 函数：全局变量大写（区分局部变量），函数单一职责（如 `clean_old_logs` 只做日志清理）；
4. 主逻辑：通过 `main` 函数统一调用，避免代码平铺直叙。
#### 1.2.6.3 编码规范（统一语法，降低出错率）
##### 1.2.6.3.1 变量规范

- **命名**：
    - 全局变量：大写 + 下划线（如 `LOG_DIR`）；
    - 局部变量：小写 + 下划线（如 `disk_usage`）；
    - 禁止单字符变量（除循环变量 `i/j` 外），禁止拼音 / 无意义命名（如 `a=10`）。
- **使用**：
    - 变量引用必须加 `${}`（避免歧义，如 `${name}s` 而非 `$names`）；
    - 字符串变量必须用双引号包裹（避免空格 / 通配符解析错误，如 `"$LOG_DIR"`）；
    - 禁止使用未定义变量（开启 `set -u` 强制检查）。
```bash
# 正确示例
user_name="张三"
echo "欢迎 ${user_name} 使用脚本"  # 加{}，双引号包裹


# 错误示例
username=张三
echo 欢迎 $username使用脚本  # 无{}，易歧义；无双引号，空格会截断
```
##### 1.2.6.3.2 注释规范

- **强制规则**：
    1. 脚本头部必须有元信息注释（见文件结构示例）；
    2. 函数 / 核心逻辑必须加注释（说明功能，而非重复代码）；
    3. 特殊逻辑（如正则、复杂判断）加行内注释；
    4. 禁止冗余注释（如 `i=1 # 定义变量i`）；
    5. 多行注释用 `:<<EOF ... EOF`，禁止逐行 `#` 堆叠（长注释块）。
```bash
# 计算磁盘使用率（核心逻辑：过滤df输出，提取百分比并去掉%）
disk_usage=$(df -h $LOG_DIR | grep -v Filesystem | awk '{print $5}' | sed 's/%//g')
```

##### 1.2.6.3.3 缩进与格式

- **强制规则**：
    1. 缩进用 4 个空格（禁止 Tab，避免不同编辑器显示不一致）；
    2. 条件 / 循环语句的 `then`/`do` 单独一行（或加空格分隔）；
    3. 管道命令多行书写时，`|` 放在行尾，便于阅读；
    4. 长命令用 `\` 换行（每行不超过 80 字符）。
```bash
# 条件语句（then单独一行，缩进4空格）
if [[ $disk_usage -gt 80 ]]; then
    log_error "磁盘使用率超标"
fi

# 管道命令多行书写
find $LOG_DIR \
    -name "*.log" \
    -type f \
    -mtime +7 \
    -exec gzip {} \;
```

##### 1.2.6.3.4 条件 / 循环规范
- **条件判断**：
    1. 优先用 `[[ ]]` 代替 `[ ]`（支持正则、&&/||，无需转义）；
    2. 数值判断用 `(( ))`（如 `((i > 10))`），禁止用 `>`/`<`（易被解析为重定向）；
    3. 文件判断优先用 `-f/-d/-e` 等，避免直接 `ls` 判断。
- **循环语句**：
    1. 遍历数组用 `for item in "${arr[@]}"`（双引号包裹，避免空格分割）；
    2. 禁止无限循环无退出条件（必须有 `break`/ 超时控制）。
```bash
# 条件判断
if [[ $user_name =~ ^[a-zA-Z0-9_]+$ ]]; then  # 正则匹配
    echo "用户名合法"
fi

# 数值判断
if (( count >= 10 )); then
    break
fi

# 数组遍历
fruits=("苹果" "香蕉" "橙子")
for fruit in "${fruits[@]}"; do
    echo $fruit
done
```

##### 1.2.6.3.5 算术运算规范
- 优先用 `$(( ))`（如 `$((a + b))`）或 `let`（如 `let sum+=1`）；
- 浮点数运算用 `bc`/`awk`（Shell 不原生支持）；
- 运算前必须校验变量是否为数值（避免 `aa.sh` 这类非数值导致语法错误）。
```bash
num=10
sum=$((num * 2))  # 整数运算
float_sum=$(echo "scale=2; $num * 3.14" | bc)  # 浮点数运算（保留2位
```
#### 1.2.6.4 安全规范
##### 1.2.6.4.1 权限控制

- 禁止用 `root` 执行非必要脚本（最小权限原则）；
- 脚本中涉及文件修改 / 删除时，校验文件路径（防止路径遍历，如 `../` 注入）；
- 禁止硬编码密码 / 密钥（通过环境变量 / 配置文件传入，且配置文件权限设为 `600`）。

##### 1.2.6.4.2 输入校验

- 所有外部输入（参数、用户输入、环境变量）必须校验合法性：
    - 路径参数校验：`[[ $path =~ ^/[a-zA-Z0-9_/]+$ ]]`；
    - 数值参数校验：`[[ $num =~ ^[0-9]+$ ]]`；
    - 禁止输入包含 `;`/`|`/`&` 等特殊字符（避免命令注入）。
```bash
# 校验路径参数，防止路径遍历
if [[ $LOG_DIR =~ \.\. ]]; then
    log_error "非法路径：包含../"
fi
```

##### 1.2.6.4.3 危险命令管控

- 禁止使用 `rm -rf /*`（必须指定具体目录，如 `rm -rf $LOG_DIR/*.log.gz`）；
- `rm` 命令前先校验目录是否存在（避免误删）；
- 禁止使用 `eval`（易导致命令注入，如 `eval "$user_input"`）；
- 管道执行远程脚本（`curl | bash`）必须校验来源（如 MD5 校验）。

##### 1.2.6.4.4 错误处理

- 开启 `set -e`（命令失败立即退出）、`set -u`（未定义变量报错）、`set -o pipefail`（管道错误检测）；
- 用 `trap` 捕获 `ERR`/`INT`/`EXIT` 信号（如捕获 Ctrl+C，清理临时文件）；
- 所有命令执行后检查返回码（`$?`），失败时输出日志并退出。
```bash
# 开启安全参数
set -euo pipefail

# 捕获信号：退出时清理临时文件
trap 'rm -f /tmp/tmp_log*; log_info "脚本被中断，清理临时文件"' INT EXIT
```

##### 1.2.6.4.5 输出重定向

- 禁止将错误输出重定向到 `/dev/null`（除非明确确认无需关注）；
- 脚本执行日志必须落地（便于问题排查）；
- 敏感操作（如删除文件）执行前输出提示（或加 `-f` 参数确认）
# 二、shell 变量
## 2.1 变量基础

### 2.1.1 变量场景

#### 2.1.1.1 数据存储
```ini
所谓的数据存储，我们从三方面来理解这句话：

1、数据保存到哪里 -- 各种媒介，CPU、内存、磁盘、磁带、网盘...

2、数据保存的效果 -- 完整、安全、有效

3、数据保存的单元 -- 存储空间

数据的存储空间默认不是一个整体，而是由一个个的存储单元组成，每一个存储单元都有一个唯一的整数编号，我们称这个编号为：地址

存储单元的作用：存储数据+读写数据

存储空间大小：1字节(B) = 8bit == 00000000

地址特点：十六进制，例如：0x20000000
```
#### 2.1.1.2 存储样式

对于数据的存储来说，主要有两种样式：物理地址和逻辑地址。
```ini
物理地址：内存或硬盘中真正存储数据的位置，也就是说通过磁盘设备查找的位置

逻辑地址：用于查找物理地址的存储块地址叫逻辑地址。程序中用的地址一般都是逻辑地址

逻辑地址包括两部分：起始值(十六进制)+偏移量(十六进制)

数据表的描述主要是逻辑地址，因为程序一般存储的是逻辑地址。
```
数据一旦存储下来就不再发生变化了，而程序中可能会在很多场景中用到同一个数据，就会出现两个问题：
```ini
1 物理地址人听得懂，机器看不懂

- 所以用逻辑地址找物理地址

2 软件可以通过逻辑地址找到数据地址，但是软件不懂场景

- 所以人用逻辑地址的别名来代指向同一个xx地址

应用程序中为了 多场景应用这个逻辑地址的别名，本质上就是“变量”。
```
#### 2.1.1.3 变量本质
变量的本质其实就是 通过一个名称帮助程序快速找到内存中具体数据的地址。

- 变量说白了就是指向xx值。
变量存在的意义是，脚本文件执行的时候，能够让脚本逻辑不变化的前提下，可以根据实际的数据进行相同逻辑的处理，从而满足当前业务需求

#### 2.1.1.4 编程语言中的变量使用
```ini
静态编译语言：

使用变量前，先声明变量类型，之后类型不能改变，在编译时检查。

如：java，c

动态编译语言：

不用事先声明，可随时改变类型。

如：bash，Python


强类型语言：

不同类型数据操作，必须经过强制转换才同一类型才能运算。

如java ， c# ，python

示例：

           print('shuji' + 10) 提示出错，不会自动转换类型

           print('shuji' + str(10)) 结果为magedu10，需要显示转换类型

弱类型语言：

语言的运行时会隐式做数据类型转换。无须指定类型，默认均为字符型；

参与运算会自动进行隐式类型转换；变量无须事先定义可直接调用。

如：bash ，php，javascript

示例：

echo 'aaa'+222
```

### 2.1.2 变量定义
Shell 脚本中的变量是存储数据的容器，用于在脚本运行过程中传递和操作信息。与编译型语言不同，Shell 中的变量**无需显式声明类型**，其值始终为字符串（即使看起来像数字），但可参与算术运算。

#### 2.1.2.1 变量定义
在 Shell 中，变量通过 `变量名=值` 的形式定义。**注意：等号两侧不能有空格**，否则会被解释为命令。
##### ✅ 2.1.2.1.1 正确定义方式
```bash
name="Alice"
age=25
site=github.com
```
##### ❌ 2.1.2.1.2 错误示例（会导致语法错误）
```bash
name = "Alice"   
# 错误：等号两边有空格，Shell 会尝试执行名为 "name" 的命令
```
##### 🔍 2.1.2.1.3 使用变量
使用 `$变量名` 或 `${变量名}` 引用变量值。推荐在复杂上下文中使用花括号以避免歧义。
```bash
echo ${name}
echo $age
```
💡 提示：`${}` 在拼接字符串时特别有用：
```bash
file="log"
echo "${file}_2025.txt"  # 输出：log_2025.txt
```
##### 📌 2.1.2.1.4 只读变量（常量）
```bash
readonly PI=3.14159
# PI=3.14  # 执行会报错：readonly variable
```
使用 `readonly` 声明变量后，其值不可修改。

##### 🧹 2.1.2.1.5 删除变量

使用 `unset` 可删除变量（不能删除 readonly 变量）。

```bash
unset age
echo $age  # 输出为空
```
#### 2.1.2.2 变量命名规范
##### 2.1.2.2.1 变量命名规则
Shell 变量名的字符和格式有严格限制，是定义变量的第一要求：

| 规则    | 说明                                    | 正确示例                       | 错误示例                                                                    | 错误原因                  |
| ----- | ------------------------------------- | -------------------------- | ----------------------------------------------------------------------- | --------------------- |
| 字符限制  | 仅允许「字母（大小写）、数字、下划线（_）」                | `name`、`USER_AGE`、`var123` | `user-name`、`var@123`                                                   | 含非法字符（-、@）            |
| 开头限制  | 不能以数字开头                               | `var1`、`_var`              | `1var`、`123_name`                                                       | 数字开头，Shell 解析为命令 / 数值 |
| 长度限制  | 无官方长度限制（建议≤64 字符）                     | `LOG_DIR`、`file_count`     | 超长变量名（如`a123456789012345678901234567890123456789012345678901234567890`） | 可读性差，无语法错误但不推荐        |
| 关键字禁止 | 不能使用 Shell 关键字（如 if/for/while/echo 等） | `for_var`                  | `for`、`i`                                                               |                       |
```bash
#!/bin/bash
# 正确命名
name="张三"
USER_AGE=25
var123="test"
_var="下划线开头"

# 错误命名（取消注释查看报错）
# user-name="李四"  # 含-，报错：-bash: user-name=李四: 未找到命令
# 1var="数字开头"    # 报错：-bash: 1var=数字开头: 未找到命令
# for="关键字"       # 报错：-bash: for=关键字: 语法错误
```
##### 2.1.2.2.2 赋值语法规则
变量赋值的核心是 `变量名=值`，等号的处理直接决定是否报错

|规则|说明|正确示例|错误示例|错误原因|
|---|---|---|---|---|
|等号无空格|`=` 前后不能有空格（空格会被 Shell 解析为命令分隔）|`age=20`|`age = 20`|Shell 把`age`当作命令，`=`当作参数，报错「age：未找到命令」|
|禁止多变量连续赋值|不推荐 `a=b=c=10`（虽能执行，但易引发逻辑问题）|`a=10; b=10; c=10`|`a=b=c=10`|实际是`c=10`，`b=c`，`a=b`，最终`a`值为`c`（非 10）|
|空值赋值合法|允许定义空变量（`var=` 或 `var=""`）|`empty_var=`、`empty_var=""`|-|空变量可后续赋值，引用时需注意（开启`set -u`会报错）|
|赋值与引用分离|赋值时变量名不加`$`，引用时必须加`$`（或`${}`）|`num=10; echo $num`|`$num=10`|赋值时加`$`会解析为 “未定义变量”，报错「=10：未找到命令」|
```bash
#!/bin/bash
# 正确赋值
age=20
empty_var=""  # 空值赋值
echo "age=$age，empty_var=$empty_var"

# 错误赋值（取消注释查看报错）
# age = 20    # 等号有空格，报错
# $num=10     # 赋值加$，报错
# a=b=c=10    # 连续赋值（逻辑错误）
# echo "a=$a, b=$b, c=$c"  # 输出a=c, b=c, c=10
```
##### 2.1.2.2.3 变量值的处理规则
|规则|说明|正确示例|错误示例|错误原因|
|---|---|---|---|---|
|含空格 / 通配符需加引号|值含空格、`*`、`?`、`[ ]`等，必须用单 / 双引号包裹|`path="/tmp/test dir"`、`pattern="*.sh"`|`path=/tmp/test dir`|Shell 把`dir`当作独立命令，报错「dir：未找到命令」|
|单 / 双引号区别|双引号解析变量，单引号原样输出（无变量解析）|`name="张三"; str="hello $name"`|`str='hello $name'`|单引号内`$name`不解析，输出`hello $name`（非语法错误，按需选择）|
|特殊字符转义|若不用引号，需用`\`转义特殊字符（$、&、空格等）|`str=hello\ \$world`|`str=hello $world`|`$world`被解析为未定义变量，输出`hello`|
|多行值处理|变量值需换行时，用`\n`转义或 HereDoc，Shell 默认忽略换行|`multi_line="line1\nline2"`|`multi_line="line1 line2"`|直接换行赋值会报错，需转义或 HereDoc|
```bash
#!/bin/bash
# 正确：值含空格加双引号
path="/tmp/test dir"
echo "path=$path"

# 正确：特殊字符转义
str=hello\ \$world
echo "str=$str"  # 输出hello $world

# 错误：值含空格不加引号（取消注释报错）
# path=/tmp/test dir  # 报错：dir：未找到命令

# 多行值处理
multi_line="line1\nline2"
echo -e "$multi_line"  # -e解析\n，输出两行
```
#### 2.1.2.3 特殊类型变量的定义要求
除基础变量外，只读、环境、数组、局部变量的定义有额外规则：

##### 2.1.2.3.1 只读变量（readonly/declare -r）

- 规则 1：定义后**不可修改、不可撤销**（unset 无效）；
- 规则 2：可直接定义 `readonly 变量名=值`，或先定义再标记 `var=10; readonly var`；
- 规则 3：禁止重复定义只读变量（重复定义会报错）。
```bash
#!/bin/bash
# 正确定义只读变量
readonly PI=3.14
# 或
var=10
declare -r var  # 等价readonly

# 错误操作（取消注释报错）
# PI=3.1415  # 只读变量无法修改，报错
# unset PI   # 只读变量无法撤销，报错
# readonly PI=3.14  # 重复定义，报错
```
##### 2.1.2.3.2 环境变量（export）
- 规则 1：需用`export`声明，才能被子 Shell 继承（未 export 仅当前 Shell 有效）；
- 规则 2：可「先定义后 export」或「定义 + export 一步到位」；
- 规则 3：环境变量名建议大写（规范），如`export APP_VERSION="2.0"`。

```bash
#!/bin/bash
# 正确定义环境变量
app_name="myapp"
export app_name  # 方式1

export app_version="2.0"  # 方式2（推荐）

# 验证：子Shell可访问环境变量
bash -c 'echo "子Shell中app_name=$app_name"'  # 输出myapp
```

##### 2.1.2.3.3 数组变量
（1）索引数组（默认，bash 所有版本支持）

- 规则 1：用`()`包裹值，值之间用空格分隔（索引从 0 开始）；
- 规则 2：禁止值含空格不加引号（会被解析为多个元素）；
- 规则 3：追加元素用`数组名[${#数组名[@]}]=新值`。

（2）关联数组（bash 4.0+ 支持）

- 规则 1：必须先声明 `declare -A 数组名`，再赋值（键值对）；
- 规则 2：键名可含数字 / 字符串，无需连续；
- 规则 3：CentOS 6 等低版本 bash 不支持，需升级。
```bash
#!/bin/bash
# 索引数组（正确）
fruits=("苹果" "香蕉" "橙子")  # 值含空格加引号
echo "fruits[1]=${fruits[1]}"  # 输出香蕉

# 关联数组（正确）
declare -A user_info
user_info["name"]="张三"
user_info["age"]=25

# 错误：关联数组未声明（取消注释报错）
# user_info2["name"]="李四"  # bash4+报错，低版本解析为索引数组
```
##### 2.1.2.3.3 局部变量
- 规则 1：仅能在**函数内**定义，用`local 变量名=值`；
- 规则 2：局部变量仅函数内生效，函数外无法访问；
- 规则 3：`local`必须放在函数内第一行（赋值前），否则先赋值为全局变量，再标记局部（逻辑错误）。

```bash
#!/bin/bash
# 正确定义局部变量
func() {
    local local_var="局部变量"  # 函数内第一行定义
    echo "函数内：$local_var"
}

func
echo "函数外：$local_var"  # 输出空（无法访问）

# 错误：local位置错误（取消注释验证）
# func2() {
#     var="全局变量"
#     local var="局部变量"  # 先赋值全局，再标记局部
#     echo "函数内：$var"  # 输出局部变量，但全局var已被赋值
# }
# func2
# echo "函数外：$var"  # 输出全局变量（逻辑错误）
```
#### 2.1.2.4 变量定义的禁止行为（常见陷阱）

| 禁止行为          | 示例                              | 后果                                  |
| ------------- | ------------------------------- | ----------------------------------- |
| 变量名含空格 / 特殊符号 | `user name="张三"`、`var@123=test` | 语法错误，报错「未找到命令」                      |
| 赋值时变量名加`$`    | `$num=10`                       | 解析为 “未定义变量”，报错「=10：未找到命令」           |
| 只读变量重复定义 / 修改 | `readonly PI=3.14; PI=3.1415`   | 报错「只读变量无法修改」                        |
| 函数外使用`local`  | `local var=10`                  | 语法错误，报错「local：仅在函数内有效」              |
| 未转义的`$`直接赋值   | `str=hello$world`               | `$world`被解析为未定义变量，最终`str=hello`     |
| 数组元素含空格不加引号   | `arr=(test dir)`                | 被解析为两个元素（test、dir），而非一个元素（test dir） |
#### 2.1.2.5 变量定义的最佳实践（规范层面）

1. **命名规范**：
    
    - 全局变量 / 环境变量：大写 + 下划线（如`LOG_DIR`、`APP_VERSION`）；
    - 局部变量 / 函数内变量：小写 + 下划线（如`file_count`、`user_name`）；
    - 数组变量：复数名词（如`fruits`、`users`）；
    - 禁止单字符变量（循环变量`i/j`除外）、禁止拼音 / 无意义命名（如`a=10`）。
2. **安全规范**：
    
    - 所有外部输入的变量（参数、用户输入）必须校验合法性（数值、路径等）；
    - 路径变量校验是否含`../`（防止路径遍历）；
    - 开启`set -u`（未定义变量报错），提前暴露未定义变量问题。
3. **可读性规范**：
    
    - 变量名见名知意（如`LOG_DIR`而非`dir`）；
    - 复杂值赋值时换行（如数组、多行字符串），提升可读性；
    - 变量定义集中放在脚本开头（全局变量）或函数开头（局部变量）。
### 2.1.3 变量分类
Shell 变量的分类可以从**作用域 / 生命周期**、**定义主体**、**数据类型**等维度划分，其中**按作用域分类**是最常用、最核心的方式。
#### 2.1.3.1 按作用域 / 生命周期分类（核心）
##### 2.1.3.1.1 局部变量（Loacl Variable）
- **定义**：仅在**当前 shell 进程**或**函数内部**有效，子进程 / 子 shell 无法访问，退出当前 shell / 函数后立即销毁。
- **声明方式**：普通 shell 中直接赋值（默认当前 shell 局部）；函数内需用 `local` 关键字显式声明（否则会升级为当前 shell 的全局变量）。
```bash
15:33:45 root@redis01:~# cat local_variable.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: local_variable.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
# 普通 shell 的局部变量，只对当前 shell 有效
var="local variable"
echo ${var}


# 函数内部的局部变量（仅在函数内部有效）
test_func(){
  local func_inner_var="func_inner"
  echo ${func_inner_var}
}

test_func

# 无输出，函数外不可见
echo ${func_inner_var}

15:33:46 root@redis01:~# bash local_variable.sh
local variable
func_inner
```

- **查看方式**：`set` 命令（列出所有局部变量 + 环境变量）。
##### 2.1.3.1.2 环境变量（Environment Variable）
- **定义**：全局有效，当前 shell 及所有**子 shell / 子进程**（如 bash、python 脚本、其他命令）均可访问。
- **声明方式**：通过 `export` 关键字导出（临时生效），或写入配置文件持久化。
```bash
15:44:47 root@redis01:~# cat enviroment_variable.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: enviroment_variable.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
# 临时导出环境变量
export USER_NAME="zhangsan"
echo ${USER_NAME}

# 子 shell 中访问
/bin/bash -c 'echo ${USER_NAME}'

15:44:49 root@redis01:~# bash enviroment_variable.sh
zhangsan
zhangsan
15:44:51 root@redis01:~#
```

**常用系统内置环境变量**：

- `PATH`：命令搜索路径（执行`ls`时系统查找的目录）；
- `HOME`：当前用户主目录（如`/home/zhangsan`）；
- `SHELL`：当前使用的 shell（如`/bin/bash`）；
- `LANG`：语言环境（如`zh_CN.UTF-8`）；
- `PWD`：当前工作目录（等价于`pwd`命令）
- 
**查看方式**：`env`/`printenv`/`export` 命令。
**持久化**：临时`export`仅当前 shell 有效，需写入配置文件：
    - 当前用户：`~/.bashrc` 或 `~/.bash_profile`；
    - 所有用户：`/etc/profile` 或 `/etc/environment`；
    - 生效：`source ~/.bashrc`（立即生效）或重启终端。
##### 2.1.3.1.3 位置参数变量
- **定义**：shell 预定义的、用于接收**传递给脚本 / 函数的参数**的变量。

|变量|含义说明|
|---|---|
|`$0`|表示脚本本身的名称（若通过软链接执行，`$0` 显示软链接名）|
|`$1~$9`|第 1 到第 9 个位置参数（传入的第 1 个参数是 `$1`，第 2 个是 `$2`，依此类推）|
|`${10}`|第 10 及以上位置参数（必须用花括号包裹，否则 `$10` 会被解析为 `$1 + 0`）|
|`$#`|传入的位置参数的**总个数**|
|`$*`|所有位置参数的集合（加引号时 `"$*"` 会将所有参数拼接为一个字符串）|
|`$@`|所有位置参数的集合（加引号时 `"$@"` 会保留每个参数的独立性，推荐优先用）|
|`$?`|上一个命令 / 脚本的退出状态码（0 = 成功，非 0 = 失败，常用来判断参数处理结果）|
###### 2.1.3.1.3.1 示例
```bash
15:50:38 root@redis01:~# cat test.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
# 打印脚本名称
echo "脚本名称：$0"

# 打印前3个位置参数
echo "第1个参数：$1"
echo "第2个参数：$2"
echo "第3个参数：$3"

# 打印参数总个数
echo "参数总个数：$#"

# 打印所有参数（$* 方式）
echo "所有参数（\$*）：$*"

# 打印所有参数（$@ 方式）
echo "所有参数（\$@）：$@"

15:50:39 root@redis01:~# bash test.sh 苹果 香蕉 橙子
脚本名称：test.sh
第1个参数：苹果
第2个参数：香蕉
第3个参数：橙子
参数总个数：3
所有参数（$*）：苹果 香蕉 橙子
所有参数（$@）：苹果 香蕉 橙子
15:50:44 root@redis01:~#
```
###### 2.1.3.1.3.2 $* 和 $@ 的核心区别（重点）
表面上 `$*` 和 `$@` 输出相同，但**加引号后** 行为完全不同：

- `"$*"`：将所有参数拼接成**一个字符串**（用系统默认分隔符 `IFS`，默认是空格）；
- `"$@"`：将每个参数视为**独立的个体**（保留参数边界，适合循环处理）。
```bash
15:51:33 root@redis01:~# cat test.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
echo "=== 循环 \$*（加引号）==="
for arg in "$*"; do
    echo "参数：$arg"
done

echo -e "\n=== 循环 \$@（加引号）==="
for arg in "$@"; do
    echo "参数：$arg"
done

15:51:34 root@redis01:~# bash test.sh 苹果 "香蕉 葡萄" 橙子
=== 循环 $*（加引号）===
参数：苹果 香蕉 葡萄 橙子

=== 循环 $@（加引号）===
参数：苹果
参数：香蕉 葡萄
参数：橙子
```
###### 2.1.3.1.3.3 处理超过 9 个参数
`$10` 会被 Shell 解析为 `$1 + 0`，因此第 10 个及以上参数必须用 `${数字}` 形式：
```bash
15:53:08 root@redis01:~# cat test01.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test01.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
echo "第10个参数：${10}"
echo "第11个参数：${11}"

15:53:11 root@redis01:~# bash test01.sh 1 2 3 4 5 6 7 8 9 10 11
第10个参数：10
第11个参数：11
15:53:18 root@redis01:~# 
```
#### 2.1.3.2 按照定义主体分
##### 2.1.3.2.1 用户自定义变量
用户手动创建的变量，用于临时存储数据
```bash
age=25
name="Tom"
arr=(a b c)
```
##### 2.1.3.2.2 系统内置变量
shell / 操作系统预定义的变量，用于存储系统配置、环境信息，比如：

- `PATH`、`HOME`、`SHELL`（环境变量）；
- `$?`、`$$`（特殊变量）。
#### 2.1.3.3 按数据类型分类（Shell 弱类型，无严格类型区分）
##### 2.1.3.3.1 字符串变量（最常用）
- **单引号**：纯字符串，不解析变量 / 转义符（强引用）：
```bash
15:56:15 root@redis01:~# name="zhangsan"
15:56:21 root@redis01:~# name_ex='xixi and $name'
15:56:48 root@redis01:~# echo $name_ex
xixi and $name
15:56:54 root@redis01:~# 
```
- **双引号**：解析变量（弱引用）
```bash
15:56:54 root@redis01:~# name="zhangsan"
15:57:41 root@redis01:~# name_ex="xixi and $name"
15:57:46 root@redis01:~# echo $name_ex
xixi and zhangsan
15:57:47 root@redis01:~#
```
- **无引号**：简单字符串，含空格 / 特殊字符需加引号：
```bash
15:57:47 root@redis01:~# str=hello
15:58:26 root@redis01:~# str=hello world
Command 'world' not found, but can be installed with:
snap install world
15:58:32 root@redis01:~# 
```

##### 2.1.3.3.2 数值变量
本质是字符串，需通过 `let`、`(( ))`、`expr` 等工具进行数值运算：
```bash
num=10
let num=num+5  # num=15
echo $((num*2))  # 输出：30
expr $num + 3  # 输出：18
```
##### 2.1.3.3.3 数组变量
索引从 0 开始，可存储多个字符串：
```bash
arr=(apple banana orange)
echo ${arr[0]}    # 输出：apple（第1个元素）
echo ${arr[@]}    # 输出：apple banana orange（所有元素）
echo ${#arr[@]}   # 输出：3（数组长度）
```
### 2.1.4 变量基本操作
#### 2.1.4.1 变量查看
在 Shell 中，查看变量的目的是确认变量的**值**、**属性**（如类型、只读、环境变量等）或**所有已定义变量**，常用方法如下：

|方法|用途|适用场景|
|---|---|---|
|`echo $变量名`|查看单个变量的值|快速验证单个变量赋值结果|
|`printf "%s\n" $变量名`|格式化查看变量值（避免特殊字符问题）|变量值含空格 / 特殊符号时|
|`set`|查看所有变量（包括本地 / 环境 / 函数）|排查所有已定义变量|
|`env`/`export`|查看环境变量（全局可访问）|确认环境变量是否生效|
|`declare -p 变量名`|查看变量的**值 + 属性**（类型 / 只读等）|调试变量属性问题|
```bash
16:06:12 root@redis01:~# cat show_variable.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: show_variable.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
# 先定义测试变量
name="张三"
age=25
export PATH=$PATH:/tmp  # 环境变量示例

# 1. 基础查看：echo
echo "echo 查看单个变量："
echo "name = $name"
echo "age = $age"
echo "-------------------------"

# 2. 格式化查看：printf（处理含空格/特殊字符的变量）
address="北京市 朝阳区"
echo -e "\nprintf 格式化查看："
printf "address = %s\n" "$address"
echo "-------------------------"

# 3. set 查看所有变量（本地+环境+函数）
# 注：输出内容较多，可结合 grep 过滤指定变量
echo -e "\nset 过滤查看 name 变量："
set | grep "^name="
echo "-------------------------"

# 4. env/export 查看环境变量
echo -e "\nexport 查看 PATH 环境变量（截取末尾）："
export | grep "^PATH=" | awk -F'/tmp' '{print $1 "/tmp..."}'
echo "-------------------------"

# 5. declare -p 查看变量值+属性（最推荐的调试方式）
echo -e "\ndeclare -p 查看变量属性："
declare -p name age address

16:06:17 root@redis01:~# bash show_variable.sh 
echo 查看单个变量：
name = 张三
age = 25
-------------------------

printf 格式化查看：
address = 北京市 朝阳区
-------------------------

set 过滤查看 name 变量：
name=张三
-------------------------

export 查看 PATH 环境变量（截取末尾）：
-------------------------

declare -p 查看变量属性：
declare -- name="张三"
declare -- age="25"
declare -- address="北京市 朝阳区"
```
#### 2.1.4.2 变量定义
Shell 变量默认是**字符串类型**，定义的核心规则是「变量名 = 值」，无类型限制（除非用 `declare` 声明）。
1. 变量名：只能包含**字母、数字、下划线**，且**不能以数字开头**（区分大小写）；
2. 赋值符号 `=` 两边**不能有空格**（空格会被 Shell 解析为命令分隔符）；
3. 变量值含**空格 / 特殊字符**时，需用单引号 `''` 或双引号 `""` 包裹；
4. 引用变量：用 `$变量名` 或 `${变量名}`（推荐后者，避免变量名拼接歧义）。

*赋值方式（4 种常用）*

|赋值方式|语法示例|说明|
|---|---|---|
|直接赋值|`var=value`|最简单的赋值，值为固定字符串|
|命令替换赋值|`var=$(命令)` 或 `var=`命令 ``|变量值为命令的执行结果|
|算术赋值|`var=$((算术表达式))`|整数运算（仅支持整数，浮点数需用 bc）|
|交互赋值|`read [-p 提示语] var`|从用户输入获取变量值|
```bash
16:08:26 root@redis01:~# cat define_variable.sh 
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: define_variable.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 1. 直接赋值（核心规则演示）
var1=hello          # 正确：无空格
# var2 = world      # 错误：=两边有空格（运行会报错）
var3="hello world"  # 含空格，双引号包裹
var4='hello $var1'  # 单引号：原样输出（不解析变量）
var5="hello $var1"  # 双引号：解析变量

echo "1. 直接赋值："
echo "var1 = $var1"
echo "var3 = $var3"
echo "var4 = $var4"  # 输出：hello $var1
echo "var5 = $var5"  # 输出：hello hello
echo "-------------------------"

# 2. 命令替换赋值（$() 推荐，` ` 兼容旧版本）
current_dir=$(pwd)       # 获取当前目录
file_count=$(ls | wc -l) # 统计当前目录文件数
echo -e "\n2. 命令替换赋值："
echo "当前目录：$current_dir"
echo "当前目录文件数：$file_count"
echo "-------------------------"

# 3. 算术赋值（$(( )) 仅支持整数）
a=10
b=3
sum=$((a + b))
sub=$((a - b))
mul=$((a * b))
div=$((a / b))  # 整数除法，结果取整
mod=$((a % b))
echo -e "\n3. 算术赋值："
echo "$a + $b = $sum"
echo "$a - $b = $sub"
echo "$a * $b = $mul"
echo "$a / $b = $div"  # 输出：3
echo "$a % $b = $mod"  # 输出：1
echo "-------------------------"

# 4. 交互赋值（read）
echo -e "\n4. 交互赋值："
read -p "请输入你的姓名：" username
read -p "请输入你的年龄：" userage
echo "你输入的姓名：$username，年龄：$userage"

16:08:29 root@redis01:~# bash define_variable.sh 
1. 直接赋值：
var1 = hello
var3 = hello world
var4 = hello $var1
var5 = hello hello
-------------------------

2. 命令替换赋值：
当前目录：/root
当前目录文件数：8
-------------------------

3. 算术赋值：
10 + 3 = 13
10 - 3 = 7
10 * 3 = 30
10 / 3 = 3
10 % 3 = 1
-------------------------

4. 交互赋值：
请输入你的姓名：xu
请输入你的年龄：22
你输入的姓名：xu，年龄：22
```
#### 2.1.4.3 declare 语法
`declare` 是 Shell 内置命令，用于**声明变量类型 / 修改变量属性**，解决默认字符串类型的限制（如整数、数组、只读、环境变量等）。
```bash
declare [选项] 变量名[=值]
```

|选项|作用|示例|
|---|---|---|
|`-i`|声明变量为**整数类型**（自动算术运算）|`declare -i num=10`|
|`-r`|声明变量为**只读变量**（不可修改 / 删除）|`declare -r readonly_var=test`|
|`-a`|声明变量为**索引数组**（默认数组类型）|`declare -a arr=(1 2 3)`|
|`-A`|声明变量为**关联数组**（键值对）|`declare -A dict=([name]=张三 [age]=25)`|
|`-x`|声明变量为**环境变量**（等同于 export）|`declare -x env_var=hello`|
|`-p`|查看变量的**值 + 属性**（无参数时查看所有）|`declare -p num`|
|`-u`|变量值转为**大写**（赋值时自动转换）|`declare -u str=hello`|
|`-l`|变量值转为**小写**（赋值时自动转换）|`declare -l str=HELLO`|
1. 只读变量（`-r`）一旦声明，无法修改值、无法用 `unset` 删除，仅能通过重启 Shell 清除；
2. 整数变量（`-i`）赋值非数字时，值会被设为 0；
3. 关联数组（`-A`）仅支持 Bash 4.0+，需确认 Bash 版本（`bash --version`）。

#### 2.1.4.4 declare 实践
```bash
16:08:35 root@redis01:~# vim define_variable_2.sh 
16:11:30 root@redis01:~# cat define_variable_2.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: define_variable_2.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 1. -i：声明整数变量（自动算术运算）
echo "1. 声明整数变量（-i）："
declare -i num1=10
declare -i num2=5
num1=num1 + num2  # 整数类型可直接算术赋值（无需 $(( ))）
echo "num1 = $num1"  # 输出：15
num3=abc           # 赋值非数字，值为 0
declare -i num3
echo "num3 = $num3"  # 输出：0
echo "-------------------------"

# 2. -r：声明只读变量
echo -e "\n2. 声明只读变量（-r）："
declare -r readonly_var="只读变量"
echo "readonly_var = $readonly_var"
# readonly_var=修改  # 运行会报错：readonly variable
# unset readonly_var  # 运行会报错：cannot unset: readonly variable
echo "-------------------------"

# 3. -a：声明索引数组
echo -e "\n3. 声明索引数组（-a）："
declare -a arr=(apple banana cherry)
echo "数组第1个元素：${arr[0]}"  # 索引从0开始
echo "数组所有元素：${arr[@]}"    # 输出：apple banana cherry
echo "数组长度：${#arr[@]}"      # 输出：3
# 追加元素
arr[3]="date"
echo "追加后数组：${arr[@]}"     # 输出：apple banana cherry date
echo "-------------------------"

# 4. -A：声明关联数组（键值对）
echo -e "\n4. 声明关联数组（-A）："
declare -A user_info=([name]="王五" [age]=28 [city]="上海")
echo "姓名：${user_info[name]}"   # 输出：王五
echo "年龄：${user_info[age]}"    # 输出：28
echo "所有键：${!user_info[@]}"   # 输出：name age city
echo "所有值：${user_info[@]}"    # 输出：王五 28 上海
echo "-------------------------"

# 5. -x：声明环境变量（等同于 export）
echo -e "\n5. 声明环境变量（-x）："
declare -x env_test="环境变量测试"
echo "env_test = $env_test"
# 验证是否为环境变量
export | grep "^env_test="  # 输出：env_test=环境变量测试
echo "-------------------------"

# 6. -u/-l：大小写转换
echo -e "\n6. 大小写转换（-u/-l）："
declare -u upper_str="hello world"
echo "大写转换：$upper_str"  # 输出：HELLO WORLD
declare -l lower_str="HELLO SHELL"
echo "小写转换：$lower_str"  # 输出：hello shell
echo "-------------------------"

# 7. -p：查看变量属性
echo -e "\n7. 查看变量属性（-p）："
declare -p num1 readonly_var arr user_info

16:11:32 root@redis01:~# bash define_variable_2.sh
1. 声明整数变量（-i）：
define_variable_2.sh: line 15: +: command not found
num1 = 10
num3 = abc
-------------------------

2. 声明只读变量（-r）：
readonly_var = 只读变量
-------------------------

3. 声明索引数组（-a）：
数组第1个元素：apple
数组所有元素：apple banana cherry
数组长度：3
追加后数组：apple banana cherry date
-------------------------

4. 声明关联数组（-A）：
姓名：王五
年龄：28
所有键：city age name
所有值：上海 28 王五
-------------------------

5. 声明环境变量（-x）：
env_test = 环境变量测试
-------------------------

6. 大小写转换（-u/-l）：
大写转换：HELLO WORLD
小写转换：hello shell
-------------------------

7. 查看变量属性（-p）：
declare -i num1="10"
declare -r readonly_var="只读变量"
declare -a arr=([0]="apple" [1]="banana" [2]="cherry" [3]="date")
declare -A user_info=([city]="上海" [age]="28" [name]="王五" )
```
#### 2.1.4.5 变量移除
当变量不再使用时，可通过 `unset` 命令移除变量（释放内存），核心是删除变量的定义和值。
```bash
unset [选项] 变量名/数组名
```
1. `unset` 可移除普通变量、数组、环境变量，但**无法移除只读变量**（`declare -r` 声明的）；
2. 移除数组时：`unset 数组名` 移除整个数组，`unset 数组名[索引]` 移除指定元素；
3. 移除环境变量后，该变量仅在当前 Shell 失效，子 Shell 不受影响。
```bash
16:13:22 root@redis01:~# cat unset_variable.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: unset_variable.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
#!/bin/bash
# 1. 移除普通变量
echo "1. 移除普通变量："
test_var="要移除的变量"
echo "移除前：test_var = $test_var"
unset test_var
echo "移除后：test_var = $test_var"  # 输出为空
echo "-------------------------"

# 2. 移除数组（整体/单个元素）
echo -e "\n2. 移除数组："
declare -a fruit=(apple banana cherry)
echo "移除前数组：${fruit[@]}"
# 移除单个元素（索引1）
unset fruit[1]
echo "移除索引1后：${fruit[@]}"  # 输出：apple cherry
# 移除整个数组
unset fruit
echo "移除整个数组后：${fruit[@]}"  # 输出为空
echo "-------------------------"

# 3. 移除环境变量
echo -e "\n3. 移除环境变量："
declare -x env_var="测试环境变量"
echo "移除前：env_var = $env_var"
unset env_var
echo "移除后：env_var = $env_var"  # 输出为空
# 验证环境变量是否存在
export | grep "^env_var="  # 无输出
echo "-------------------------"

# 4. 尝试移除只读变量（报错）
echo -e "\n4. 尝试移除只读变量："
declare -r readonly_var="只读变量"
echo "readonly_var = $readonly_var"
unset readonly_var  # 运行会报错：cannot unset: readonly variable

16:13:23 root@redis01:~# bash unset_variable.sh
1. 移除普通变量：
移除前：test_var = 要移除的变量
移除后：test_var = 
-------------------------

2. 移除数组：
移除前数组：apple banana cherry
移除索引1后：apple cherry
移除整个数组后：
-------------------------

3. 移除环境变量：
移除前：env_var = 测试环境变量
移除后：env_var = 
-------------------------

4. 尝试移除只读变量：
readonly_var = 只读变量
unset_variable.sh: line 45: unset: readonly_var: cannot unset: readonly variable
```
## 2.2 全局变量
### 2.2.1 基本操作
#### 2.2.1.1 基础知识
```powershell
全局变量是什么
全局变量就是：在当前系统的所有环境下都能生效的变量。

查看全局环境变量
 env 只显示全局变量,一般结合 grep 和管道符来使用
 printenv 效果与 env 等同
 export 查看所有的环境变量，包括声明的过程等信息，一般不用
 declare -x 效果与 export 类似
 
 
定义全局变量方法一：
 变量=值
 export 变量
定义全局变量方法二：（最常用）
 export 变量=值
 declare -x 
```
#### 2.2.1.2 查看全局变量
```bash
# 查看所有的全局变量
[root@rocky9 ~]# env
XDG_SESSION_ID=4
HOSTNAME=localhost
SHELL=/bin/bash
TERM=xterm
HISTSIZE=1000
...
# 查看制定的全局变量
[root@rocky9 ~]# env | grep SHELL
SHELL=/bin/bash

# 定制本地变量
[root@rocky9 ~]# envtype=local
[root@rocky9 ~]# echo $envtype
local
# 从全局变量中查看
[root@rocky9 ~]# env | grep envtype
[root@rocky9 ~]#
结果显示：
 无法从全局变量中查看本地变量的名称
```
#### 2.2.1.3 定制全局变量
```bash
方法1定制全局变量
[root@rocky9 ~]# echo $envtype
local
[root@rocky9 ~]# env | grep envtype
[root@rocky9 ~]# export envtype
[root@rocky9 ~]# env | grep envtype
envtype=local
方法2定制全局变量
[root@rocky9 ~]# export myuser=root
[root@rocky9 ~]# env | grep myuser
myuser=root
鸡肋方法定制全局变量
[root@rocky9 ~]# declare -x mydir=/root
[root@rocky9 ~]# env | grep mydir
mydir=/root
清理全局变量
[root@rocky9 ~]# unset envtype myuser mydir
```
### 2.3.2 文件体系
Shell 变量的 “持久化” 和 “全局生效” 依赖于系统的配置文件体系，本节聚焦与变量紧密相关的核心文件：**变量文件（自定义 / 系统）**、`bashrc`/`bash_profile`、`profile`
#### 2.3.2.1 变量文件
##### 2.3.2.1.1 核心概念
**变量文件**是专门用于集中定义、管理 Shell 变量的文本文件（通常为 `.sh` 或无后缀），核心作用是：

- 避免变量重复定义（如多个脚本共用的路径、常量）；
- 统一维护变量（修改文件即可同步所有引用处）；
- 实现变量的 “复用” 和 “批量加载”。
##### 2.3.2.1.2 核心要点
1. **变量文件的格式**：与普通 Shell 脚本一致，仅包含变量定义、`export` 导出等逻辑（无复杂命令，避免加载时执行不必要操作）；
2. **加载方式**：
    - `source 变量文件路径`（或 `. 变量文件路径`）：在**当前 Shell 进程**加载（变量生效），不新建子进程；
    - 直接执行 `./变量文件`：新建子进程执行，变量仅在子进程生效（无意义）；
3. **生效范围**：
    - 临时生效：仅当前 Shell 会话（加载后未写入配置文件）；
    - 永久生效：将 `source 变量文件` 写入 `bashrc`/`profile` 等全局配置文件。


#### 2.3.2.2 bashrc 和 bash_profile
`bashrc` 和 `bash_profile` 是 Bash Shell 的核心初始化文件，用于配置 Shell 环境（变量、别名、函数等），核心区别在于**加载时机**：

| 特性   | `.bashrc`                              | `.bash_profile`（`.bash_login`/`.profile` 是备选） |
| ---- | -------------------------------------- | --------------------------------------------- |
| 加载场景 | 非登录 Shell（如终端直接打开、SSH 连接后新建终端）         | 登录 Shell（如 SSH 首次登录、控制台登录）                    |
| 加载次数 | 每次新建 Shell 会话都加载                       | 仅登录时加载一次                                      |
| 核心作用 | 定义本地变量、别名、函数（高频使用）                     | 定义环境变量、登录时的一次性操作（如加载 bashrc）                  |
| 生效范围 | 当前用户（`~/.bashrc`）/ 系统全局（`/etc/bashrc`） | 当前用户（`~/.bash_profile`）/ 系统全局（`/etc/profile`） |
1. **登录 Shell vs 非登录 Shell**：
    - 登录 Shell：需要输入用户名密码的 Shell（如 `bash -l`、SSH 登录）；
    - 非登录 Shell：无需认证的 Shell（如桌面终端、`bash` 命令新建会话）；
2. **联动逻辑**：多数系统的 `.bash_profile` 会主动加载 `.bashrc`（保证登录 Shell 也能使用 `.bashrc` 的配置），典型内容：
    
    ```bash
    if [ -f ~/.bashrc ]; then
        . ~/.bashrc
    fi
    ```
    
3. **生效方式**：
    - 临时生效：`source ~/.bashrc` / `source ~/.bash_profile`；
    - 永久生效：修改文件后，重启 Shell 或重新登录。

##### 2.3.2.2.1 修改～/.bashrc（定义本地变量 / 别名）
```bash
# 1. 定义本地变量（仅当前 Shell 生效，高频使用）
EDITOR="vim"
WORK_DIR="$HOME/workspace"

# 2. 定义别名（简化命令）
alias ll='ls -alh'  # 替代ls -l，显示更友好
alias cdwork='cd $WORK_DIR'  # 快速进入工作目录
alias grep='grep --color=auto'  # grep结果高亮

# 3. 定义函数（批量操作）
mkwork() {
    mkdir -p $WORK_DIR/$1  # 创建工作子目录
    cd $WORK_DIR/$1        # 进入该目录
}
```
##### 2.3.2.2.2 修改～/.bash_profile（定义环境变量）
```bash
# 1. 加载.bashrc（保证登录Shell也能使用.bashrc的配置）
if [ -f ~/.bashrc ]; then
    . ~/.bashrc
fi

# 2. 定义环境变量（登录时加载，全局生效）
export JAVA_HOME="/usr/lib/jvm/java-11-openjdk"
export MAVEN_HOME="/opt/maven"
export PATH="$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin"

# 3. 登录时的一次性操作
echo "欢迎登录！当前时间：$(date +%Y-%m-%d\ %H:%M:%S)"
echo "工作目录：$WORK_DIR"
```
##### 2.3.2.2.3 验证配置文件生效
```bash
# 1. 加载修改后的配置（临时生效）
source ~/.bashrc
source ~/.bash_profile

# 2. 验证变量
echo "EDITOR = $EDITOR"          # 输出：vim
echo "JAVA_HOME = $JAVA_HOME"    # 输出：/usr/lib/jvm/java-11-openjdk

# 3. 验证别名
ll  # 等价于ls -alh，显示文件详情
cdwork  # 快速进入~/workspace
mkwork test  # 创建~/workspace/test并进入该目录

# 4. 验证登录Shell加载（SSH重新登录或执行bash -l）
bash -l  # 模拟登录Shell，会输出欢迎语

# 执行source后验证
EDITOR = vim
JAVA_HOME = /usr/lib/jvm/java-11-openjdk

# 执行bash -l模拟登录Shell
欢迎登录！当前时间：2025-12-06 15:30:00
工作目录：/home/user/workspace
```
#### 2.3.2.3 profile
`profile` 是 Shell 登录时的**全局初始化文件**，分为两个层级：

- 系统级：`/etc/profile`（对所有用户生效）；
- 用户级：`~/.bash_profile`、`~/.bash_login`、`~/.profile`（仅对当前用户生效，优先级：`.bash_profile` > `.bash_login` > `.profile`）。

`profile` 的核心作用是：

1. 配置**全局环境变量**（如 `PATH`、`LANG`、`USER` 等）；
2. 执行登录时的一次性初始化操作（如加载系统级配置、设置 umask）；
3. 联动加载 `bashrc`（保证登录 Shell 继承非登录 Shell 的配置）。


**加载顺序**（登录 Shell 场景）：
```bash
/etc/profile → /etc/profile.d/*.sh → ~/.bash_profile → ~/.bashrc → /etc/bashrc
```
1. **umask 配置**：`profile` 通常会设置 `umask`（文件默认权限掩码），如 `umask 022`（新建文件权限为 644，目录为 755）；
2. **生效方式**：
    - 系统级：`source /etc/profile`；
    - 用户级：`source ~/.bash_profile`；
    - 永久生效：重启 Shell / 重新登录。
##### 2.3.2.3.1 修改 /etc/profile
**注意**：修改系统级文件需 root 权限，谨慎操作！
```bash
# 切换到root用户
sudo su -

# 编辑/etc/profile，追加以下内容
cat >> /etc/profile << EOF
# 系统级全局环境变量（所有用户生效）
export SYSTEM_APP_HOME="/opt/system_app"
export SYSTEM_LOG="/var/log/system_app"

# 设置umask（所有用户新建文件的默认权限）
umask 022

# 加载profile.d目录下的自定义脚本
if [ -d /etc/profile.d ]; then
    for i in /etc/profile.d/*.sh; do
        if [ -r $i ]; then
            . $i
        fi
    done
    unset i
fi
EOF
```
##### 2.3.2.3.2 创建 /etc/profile.d/custom.sh（系统级细分配置）
```bash
# 切换到root用户
sudo su -

# 新建/etc/profile.d/custom.sh，内容如下
cat > /etc/profile.d/custom.sh << EOF
#!/bin/bash
# 自定义系统级配置（所有用户生效）
alias syslog='tail -f $SYSTEM_LOG/app.log'  # 实时查看系统应用日志
export PS1="[\u@\h \W]\\$ "  # 自定义终端提示符（用户名@主机名 目录）
EOF

# 给脚本执行权限
chmod +x /etc/profile.d/custom.sh
```

##### 2.3.2.3.3 验证 profile 配置生效
```bash
# 1. 加载系统级profile（临时生效）
source /etc/profile

# 2. 验证系统级变量
echo "SYSTEM_APP_HOME = $SYSTEM_APP_HOME"  # 输出：/opt/system_app
echo "SYSTEM_LOG = $SYSTEM_LOG"            # 输出：/var/log/system_app

# 3. 验证umask
umask  # 输出：0022

# 4. 验证别名
syslog  # 等价于tail -f /var/log/system_app/app.log

# 5. 验证终端提示符（重新登录后生效）
bash -l  # 模拟登录Shell，提示符变为 [user@hostname ~]$
```

##### 2.3.2.3.4 用户级 .profile 备用配置（无 .bash_profile 时）
```bash
# 编辑~/.profile
cat > ~/.profile << EOF
# 替代.bash_profile的用户级配置
if [ -f ~/.bashrc ]; then
    . ~/.bashrc
fi

export USER_BIN="$HOME/bin"
export PATH="$PATH:$USER_BIN"
EOF

# 加载生效
source ~/.profile

# 验证
echo "USER_BIN = $USER_BIN"  # 输出：/home/user/bin
```

1. 系统级配置（`/etc/profile`、`/etc/profile.d/`）修改后，所有用户登录都会生效，需确保兼容性；
2. 不要在 `/etc/profile` 中定义用户专属配置（应放在 `~/.bash_profile`）；
3. 若修改后配置未生效，检查：
    - 是否用 `source` 加载，或是否重新登录；
    - 文件权限是否为可读（`-r`）；
    - 语法是否错误（如缺少 `fi`、`export` 拼写错误）。
#### 2.3.2.4 总结
| 文件类型                         | 作用范围 | 加载场景                   | 核心用途                         |
| ---------------------------- | ---- | ---------------------- | ---------------------------- |
| 自定义变量文件                      | 按需加载 | source 手动加载            | 集中管理脚本共用变量                   |
| ~/.bashrc                    | 当前用户 | 非登录 Shell              | 本地变量、别名、函数（高频使用）             |
| ~/.bash_profile / ~/.profile | 当前用户 | 登录 Shell               | 环境变量、登录操作、加载 .bashrc         |
| /etc/profile                 | 所有用户 | 登录 Shell               | 系统级全局环境变量、umask、加载 profile.d |
| /etc/profile.d/*.sh          | 所有用户 | 登录 Shell（由 profile 加载） | 系统级细分配置（语言、工具、别名）            |
### 2.2.3 嵌套 shell
#### 2.2.3.1 export 原理
##### 2.2.3.1.1 核心概念

嵌套 Shell 本质是「父 Shell 进程」创建「子 Shell 进程」，而进程的内存空间是**相互隔离**的 —— 默认情况下，父 Shell 定义的变量（本地变量）不会被子 Shell 感知，`export` 是打破这种隔离的核心工具。

###### 2.2.3.1.1.1 父 / 子 Shell 进程隔离

- 父 Shell：当前正在运行的 Shell 会话（如终端窗口、脚本主进程）；
- 子 Shell：由父 Shell 启动的新 Shell 进程（如执行 `bash` 命令、`(命令)` 子进程、脚本直接执行）；
- 隔离本质：每个进程有独立的内存空间，父 Shell 的变量存储在自身内存中，子 Shell 无法直接访问。

###### 2.2.3.1.1.2 export 的核心作用

`export` 是 Shell 内置命令，核心功能是：

- 将「本地变量」标记为「环境变量」，并写入父 Shell 的**环境表**（环境变量列表）；
- 当创建子 Shell 时，父 Shell 会将自己的环境表**复制一份**到子 Shell 的内存中（单向复制）；
- 子 Shell 仅能读取复制的环境变量，修改后仅作用于自身，不会同步回父 Shell。

###### 2.2.3.1.1.3 关键原理总结

|特性|本地变量（未 export）|环境变量（export 标记）|
|---|---|---|
|父 Shell 可见性|可见|可见|
|子 Shell 可见性|不可见（进程隔离）|可见（创建子 Shell 时复制环境表）|
|子 Shell 修改影响|无（子 Shell 无该变量）|仅影响子 Shell 自身，父 Shell 不受影响|
|作用域|仅当前 Shell 进程|当前 Shell + 所有子 Shell 进程|

###### 2.2.3.1.1.4 底层逻辑（简化版）
```ini
父 Shell 内存
├── 本地变量区：var1=123（仅父可见）
└── 环境表：export var2=456（标记为环境变量）
    ↓ 子 Shell 创建时，环境表被复制
子 Shell 内存
├── 本地变量区：（空，或子Shell自己定义）
└── 环境表：var2=456（复制父的环境表）
    → 子Shell修改var2=789 → 仅修改自身环境表，父的var2仍为456
```
#### 2.2.3.2 嵌套实践
##### 2.2.3.2.1 验证本地变量无法传递给子 shell
```bash
21:37:35 root@redis01:~# cat test01.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test01.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
unset local_var  # 先清空可能残留的变量，避免干扰

echo "===== 示例1：本地变量的隔离性 ====="

# 父Shell定义本地变量（仅本地，未export）
local_var="父Shell的本地变量"
declare -p local_var
echo "父Shell中 local_var = $local_var"  # 验证父Shell能看到

# 方式1：执行bash命令启动子Shell，查看变量
echo -e "\n1. 子Shell中查看本地变量："
bash -c 'echo "子Shell内 local_var = $local_var"'  # 输出为空（不可见）

# 方式2：脚本直接执行（本质是启动子Shell）
cat > sub_script1.sh << EOF
#!/bin/bash
echo "脚本sub_script1.sh（子Shell）内 local_var = \$local_var"
EOF
chmod +x sub_script1.sh
echo -e "\n3. 脚本直接执行（子Shell）查看本地变量："
./sub_script1.sh  # 输出为空（不可见）
rm -f sub_script1.sh  # 清理测试脚本
21:37:36 root@redis01:~# bash test01.sh
===== 示例1：本地变量的隔离性 =====
declare -- local_var="父Shell的本地变量"
父Shell中 local_var = 父Shell的本地变量

1. 子Shell中查看本地变量：
子Shell内 local_var = 

2. 脚本直接执行（子Shell）查看本地变量：
脚本sub_script1.sh（子Shell）内 local_var = 
```
##### 2.2.3.2.2 export 环境变量传递给子 Shell
```bash
21:39:19 root@redis01:~# cat test02.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test02.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
# 示例2：export环境变量可传递给子Shell
echo "===== 示例2：export环境变量的传递性 ====="

# 父Shell定义并export环境变量
export env_var="父Shell的环境变量"

# 方式1：bash命令启动子Shell
echo -e "\n1. 子Shell中查看环境变量："
bash -c 'echo "子Shell内 env_var = $env_var"'  # 可见


# 方式2：脚本直接执行
cat > sub_script2.sh << EOF
#!/bin/bash
echo "脚本sub_script2.sh（子Shell）内 env_var = \$env_var"
EOF
chmod +x sub_script2.sh
echo -e "\n3. 脚本直接执行（子Shell）查看环境变量："
./sub_script2.sh  # 可见
rm -f sub_script2.sh

21:39:21 root@redis01:~# bash test02.sh
===== 示例2：export环境变量的传递性 =====

1. 子Shell中查看环境变量：
子Shell内 env_var = 父Shell的环境变量

2. 脚本直接执行（子Shell）查看环境变量：
脚本sub_script2.sh（子Shell）内 env_var = 父Shell的环境变量
```

##### 2.2.3.2.3 子 Shell 修改环境变量不影响父 Shell 
```bash
21:40:41 root@redis01:~# cat test03.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test03.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
# 示例3：环境变量的单向传递（子改不影响父）
echo "===== 示例3：环境变量的单向传递 ====="

# 父Shell定义并export环境变量
export env_var="初始值（父Shell）"
echo "父Shell初始值：env_var = $env_var"

# 子Shell修改环境变量
echo -e "\n1. 子Shell内修改环境变量："
bash -c '
    echo "子Shell修改前：env_var = $env_var"
    env_var="修改后（子Shell）"  # 仅修改子Shell自身的环境表
    echo "子Shell修改后：env_var = $env_var"
'

# 父Shell再次查看变量
echo -e "\n2. 父Shell查看变量（不受子Shell修改影响）："
echo "父Shell当前值：env_var = $env_var"  # 仍为初始值

21:40:42 root@redis01:~# bash test03.sh
===== 示例3：环境变量的单向传递 =====
父Shell初始值：env_var = 初始值（父Shell）

1. 子Shell内修改环境变量：
子Shell修改前：env_var = 初始值（父Shell）
子Shell修改后：env_var = 修改后（子Shell）

2. 父Shell查看变量（不受子Shell修改影响）：
父Shell当前值：env_var = 初始值（父Shell）
```

##### 2.2.3.2.4 多层嵌套 Shell 的环境变量传递
```bash
22:11:16 root@redis01:~# cat test04.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test04.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
# # 父 Shell 定义 export 变量
export root_var="根变量（父Shell）"

# 父→子→孙：子 Shell 定义新的 export 变量，再传给孙 Shell
echo -e "\n1. 多层嵌套执行："
bash -c '
    # 子 Shell：查看父传递的变量，定义新的 export 变量
    echo "子Shell：root_var = $root_var"
    export child_var="子变量（子Shell）"

    # 孙 Shell：查看父（子 Shell）传递的变量
    bash -c "
        echo \"孙Shell：root_var = \$root_var\"
        echo \"孙Shell：child_var = \$child_var\"
        export grandchild_var=\"孙变量（孙Shell）\"
    "
'

# 父 Shell 查看孙 Shell 定义的变量（不可见，仅子→孙传递）
echo -e "\n2. 父Shell查看孙Shell定义的变量："
echo "父Shell：grandchild_var = ${grandchild_var}"  # 输出为空
22:11:18 root@redis01:~# bash test04.sh

1. 多层嵌套执行：
子Shell：root_var = 根变量（父Shell）
孙Shell：root_var = 根变量（父Shell）
孙Shell：child_var = 子变量（子Shell）

2. 父Shell查看孙Shell定义的变量：
父Shell：grandchild_var = 
```

##### 2.2.3.2.5 source 与直接执行的嵌套变量差异
```bash
11:29:37 root@redis01:~# cat test06.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test06.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
# 示例5：source（同进程）vs 直接执行（子Shell）的变量传递
echo "===== 示例5：source vs 直接执行 ====="

# 父Shell定义变量
test_var="父Shell变量"

# 编写测试脚本
cat > test_source.sh << EOF
#!/bin/bash
echo "脚本内：test_var = \$test_var"
test_var="脚本内修改后"
echo "脚本内修改后：test_var = \$test_var"
EOF
chmod +x test_source.sh

# 方式1：直接执行（子Shell，变量隔离）
echo -e "\n1. 直接执行脚本（子Shell）："
./test_source.sh
echo "父Shell（直接执行后）：test_var = $test_var"  # 仍为原值

# 方式2：source执行（同进程，变量共享）
echo -e "\n2. source执行脚本（同进程）："
source test_source.sh
echo "父Shell（source后）：test_var = $test_var"  # 被脚本修改

rm -f test_source.sh

11:29:39 root@redis01:~# bash test06.sh
===== 示例5：source vs 直接执行 =====

1. 直接执行脚本（子Shell）：
脚本内：test_var = 
脚本内修改后：test_var = 脚本内修改后
父Shell（直接执行后）：test_var = 父Shell变量

2. source执行脚本（同进程）：
脚本内：test_var = 父Shell变量
脚本内修改后：test_var = 脚本内修改后
父Shell（source后）：test_var = 脚本内修改后
```

##### 2.2.3.2.6 总结
1. **隔离性**：父 / 子 Shell 进程内存独立，本地变量默认不传递；
2. **export 作用**：将变量标记为环境变量，创建子 Shell 时单向复制给子 Shell；
3. **单向传递**：子 Shell 修改环境变量仅影响自身，父 Shell 不受影响；
4. **多层传递**：环境变量可从父→子→孙 Shell 传递，但反向不行；
5. **执行方式**：
    - 直接执行脚本：启动子 Shell，变量隔离；
    - `source`/`.` 执行脚本：同进程运行，变量共享；

#### 2.2.3.3 子 shell 创建机制
##### 2.2.3.3.1 子 shell 创建方式
###### ✅ 方式 1：使用括号 ( … ) 启动子 shell（最常见方式）
 **✔ 特点**

- `(...)` 中的命令在 **子 shell** 中执行；
- 子 shell 对变量的修改不会影响父 shell；
- 这是 bash 最常用的子 shell 方式。
```bash
11:43:58 root@redis01:~# cat demo01.sh 
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo01.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
echo "父 shell PID：$BASHPID"

x=1

(
  echo "子 shell PID：$BASHPID"
  x=2
  echo "子 shell 内 x=$x"
)

echo "父 shell 内 x=$x"
11:43:59 root@redis01:~# bash demo01.sh
父 shell PID：5358
子 shell PID：5359
子 shell 内 x=2
父 shell 内 x=1
11:44:00 root@redis01:~# 
```
###### ✅ 方式 2：命令替换 $( … ) 或 …（会隐式创建子 shell）
**✔ 特点**

- 用 `$(...)` 包裹的代码会在子 shell 执行
- 子 shell 的输出会替换为结果赋给变量；
- 子 shell 不能影响父 shell 的变量。
```bash
11:46:00 root@redis01:~# cat demo02.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo02.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
echo "父 shell PID: $BASHPID"
X=1

Y=$(
    echo "子 shell PID: $BASHPID"
    X=2
    echo "返回值"
)

echo "父 shell 中 X=$X"
echo "Y=$Y"


11:46:01 root@redis01:~# bash demo02.sh
父 shell PID: 5368
父 shell 中 X=1
Y=子 shell PID: 5369
返回值
```
###### ✅ 方式 3：执行脚本（./script.sh、sh script.sh、bash script.sh）
 **✔ 特点**

- 脚本以新进程执行 → 一定是子 shell； 
- 子脚本不能修改父 shell 的变量；
- 必须 `chmod +x` 可执行。
```bash
# 父脚本和子脚本
11:50:52 root@redis01:~# cat main.sh children.sh 
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: main.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================

echo "main PID: $$"
VAR=100

./children.sh

echo "main 中 VAR=$VAR"
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: children.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
echo "child PID: $$"
VAR=200
echo "child 中 VAR=$VAR"

11:50:55 root@redis01:~# chmod +x main.sh children.sh
11:50:58 root@redis01:~# ./main.sh 
main PID: 5406
child PID: 5407
child 中 VAR=200
main 中 VAR=100
```

👉 子脚本修改 VAR 不会回传给父脚本。
###### ⚠️ 方式 4：使用管道 |（每一段命令都在子 shell 中执行）
**✔ 特点**

- **管道右侧的命令一定在子 shell 执行**；
    
- 在子 shell 中设置的变量无法在父 shell 使用。
```bash
11:52:48 root@redis01:~# cat demo03.sh 
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo03.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
echo "父 shell PID: $BASHPID"
X=1

echo "test" | while read line; do
    echo "子 shell PID: $BASHPID"
    X=2
done

echo "父 shell 中 X=$X"

11:52:51 root@redis01:~# bash demo03.sh
父 shell PID: 5426
子 shell PID: 5428
父 shell 中 X=1
```
👉 管道导致 while 在子 shell 执行。
###### 🔄 方式 5：使用子 shell 运算符 &（后台执行也会产生子 shell）
**✔ 特点**

- 后台任务会启动子 shell；
- 不能修改父 shell。
```bash
11:54:20 root@redis01:~# cat demo04.sh 
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo04.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
echo "父 shell PID: $BASHPID"
X=1

(
    echo "后台子 shell PID: $BASHPID"
    X=2
)&

wait   # 等后台任务结束
echo "父 shell 中 X=$X"

11:54:21 root@redis01:~# bash demo04.sh
父 shell PID: 5441
后台子 shell PID: 5442
父 shell 中 X=1
```

###### 🧰 方式 6：在脚本中执行 bash -c "…" 手动创建子 shell
**✔ 特点**

- 显式启动一个新的 bash 进程；
- 常用于执行字符串命令。
```bash
11:56:19 root@redis01:~# cat  demo05.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo05.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
echo "父 shell PID: $BASHPID"
bash -c 'echo "子 shell PID: $BASHPID"'

11:56:22 root@redis01:~# bash demo05.sh
父 shell PID: 5450
子 shell PID: 5451
11:56:24 root@redis01:~# 
```

###### 🧪 方式 7：使用 subshell 语法 (COMMAND LIST) 中的多命令结构
这是方式 1 的扩展：里面可以写多条命令，依然是子 shell。
```bash
11:57:58 root@redis01:~# cat demo06.sh 
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo06.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
(
  echo "PID: $BASHPID"
  VAR=999
  sleep 1
)
```

##### 2.2.3.3.2 ❌ 不属于子 shell 的方式（容易混淆）

| 写法                 | 是否是子 shell   | 说明                        |
| ------------------ | ------------ | ------------------------- |
| {...}              | ❌ 不是         | 复合命令，但在当前 shell 执行        |
| `source script.sh` | ❌ 不是         | 在父 shell 执行，可修改父 shell 变量 |
| `. script.sh`      | ❌ 等同于 source |                           |
##### 2.2.3.3.3 🧩 一图懂子 Shell（流程图）
```bash
                          ┌────────────────────────┐
                          │   你执行了一段 Shell？  │
                          └─────────────┬──────────┘
                                        │
                                        ▼
                          ┌────────────────────────┐
                          │ 使用了 source / {} ？   │
                          │   source file.sh       │
                          │   { cmd1; cmd2; }      │
                          └───────┬────────────────┘
                                  │ 是
                                  ▼
                     ┌─────────────────────────────┐
                     │ 在当前 shell 执行（无子 shell）│
                     │ PID 不变，可修改父变量        │
                     └─────────────────────────────┘
                                  ▲
                                  │ 否
                                  │
                                  ▼
              ┌──────────────────────────────────────────────┐
              │ 属于以下任一种情况？                          │
              │ 1. ( cmd )                                    │
              │ 2. $( cmd ) / `cmd`                           │
              │ 3. command | command                          │
              │ 4. ./script.sh / bash script.sh               │
              │ 5. command &                                  │
              │ 6. bash -c 'cmd'                              │
              └───────────────────────┬──────────────────────┘
                                      │ 是
                                      ▼
                 ┌─────────────────────────────────────────────┐
                 │ 创建子 shell（新的进程）                    │
                 │ PID 变化，不影响父 shell 变量              │
                 │ 能继承 export 的变量                       │
                 └─────────────────────────────────────────────┘

```

##### 2.2.3.3.4 📘 子 Shell 速查表（Cheat Sheet）

| 写法 | 子 Shell？ | 是否能修改父变量 | 用途说明 |
|------|------------|------------------|-----------|
| `( commands )` | 🟢 **是** | 🔴 **不行** | 创建子 shell、隔离环境执行 |
| `$( commands )` | 🟢 **是** | 🔴 **不行** | 命令替换（子 shell 执行） |
| `` commands `` | 🟢 **是** | 🔴 **不行** | 旧式命令替换（不推荐） |
| `cmd \| cmd`（管道） | 🟢 **是**（管道段独立进程） | 🔴 **不行** | 文本处理、数据传递 |
| `./script.sh` | 🟢 **是** | 🔴 **不行** | 执行外部脚本 |
| `bash script.sh` | 🟢 **是** | 🔴 **不行** | 指定解释器运行脚本 |
| `bash -c "commands"` | 🟢 **是** | 🔴 **不行** | 动态执行字符串命令 |
| `command &` | 🟢 **是** | 🔴 **不行** | 后台执行任务 |
| `{ commands; }` | 🟡 **否（当前 shell）** | 🟢 **可以** | 组合多条命令但不生成子 shell |
| `source script.sh` / `. script.sh` | 🟡 **否（当前 shell）** | 🟢 **可以** | 加载脚本并在当前 shell 执行 |
#### 2.2.3.4 子 shell 创建注意事项
##### 2.2.3.4.1 () 创建子 shell 和 bash -c 创建子 shell 区分
**`()` 子 Shell (Subshell)** 和 **`bash -c` (独立子进程)** 虽然都是“子进程”，但它们的**产生方式和内存继承机制完全不同**。
###### 核心原因：Fork 与 Exec 的区别

原因在于 Linux 系统调用 `fork()` 和 `exec()` 的行为差异：

1. **`()` 子 Shell：只进行了 `fork`（克隆）**
    
    - 当 Shell 执行到 `()` 时，它会调用 `fork()` 系统调用产生一个子进程。
    - **关键点**：它**没有**接着调用 `exec()` 去加载一个新的程序。
    - 因此，子进程是父进程内存的**完整副本**。父进程此刻所有的变量（无论是否 `export`）、函数、别名、句柄，子进程都原封不动地继承了（Copy-on-Write）。
    - 这就是为什么 `local_var` 在 `()` 中可见。
        
2. **`bash -c`：进行了 `fork` + `exec`（重置）**
    
    - 当执行 `bash -c ...` 时，Shell 先 `fork()` 一个子进程。
    - **关键点**：紧接着，子进程调用了 `exec()` 系统调用来启动一个新的 `bash` 程序。
    - `exec()` 会**清空**当前进程的内存空间，加载新的程序代码。
    - 只有被标记为环境变量（`export`）的数据，才会通过环境块（Environment Block）传递给新程序。普通的本地变量在内存清空时就丢失了。

---

###### 详细对比机制

为了更清晰地理解，我们可以对比这两种方式的内部流程：

|**特性**|**方式 2: ( ... ) 子 Shell**|**方式 1: bash -c '...'**|
|---|---|---|
|**系统调用**|仅 `fork()`|`fork()` 随后立即 `exec()`|
|**内存状态**|**继承副本**：直接复制父 Shell 当前的内存快照。|**全新初始化**：内存被清空，重新初始化一个新的 Shell 环境。|
|**本地变量**|**可见**（因为它就在内存副本里）。|**不可见**（内存已重置，未 export 的变量丢失）。|
|**环境变量**|可见。|可见（通过环境块传递）。|
|**PID**|新的 PID (子进程)。|新的 PID (子进程)。|
|**对父影响**|修改变量**不会**影响父 Shell（因为是副本）。|修改变量**不会**影响父 Shell（因为是完全独立的进程）。|
###### 一个生动的比喻
() 子 Shell 就像是“影分身”： 你（父 Shell）使用影分身之术。分身拥有和你此刻一模一样的记忆和口袋里的东西（本地变量）。所以分身知道 local_var 是什么。

bash -c 就像是“雇佣新员工”： 你（父 Shell）雇佣了一个全新的员工（新 bash）来干活。你没有把口袋里的私人物品（本地变量）给他，只给了他一份公用的操作手册（环境变量）。所以新员工不知道你的 local_var 是什么，除非你把它写在手册里（export）。

###### 补充验证

虽然 `()` 能**读**到父 Shell 的变量，但它是**无法修改**父 Shell 的变量的。你可以尝试在这个子 Shell 里修改变量，退出后父 Shell 的值不会变：
```bash
local_var="Original"
(
    echo "Inside: $local_var"
    local_var="Modified"
    echo "Inside Changed: $local_var"
)
echo "Outside: $local_var"  # 这里依然是 "Original"
```
`()` 之所以能获取到 `local_var`，是因为它本质上是父 Shell 进程的一个**内存克隆**，它继承了父 Shell 所有的内部状态，而不仅仅是环境变量。
##### 2.2.3.4.2 父子 shell PID 打印问题
```bash
# 测试脚本
# 这里的 () 开启了子 shell，但是打印的 PID 号却是完全相同的
echo "父 shell PID: $$"
X=1

(
    echo "子 shell PID: $$"
    X=2
    echo "子 shell 内 X=$X"
)

echo "父 shell 中 X=$X"
```
###### ✅ 首先：\$\$ 的含义
在 **bash 脚本文件中执行时**

|场景|`$$` 的值|
|---|---|
|脚本启动后|永远是脚本进程的 PID（固定）|
|subshell `()` 内|`$$` 不变，仍是脚本 PID|
👉 因为在 **脚本中**，bash **不会改变 `$$` 的值**，即使进入 subshell，也保持为脚本自己的 PID。
###### 🔍 为什么 subshell（子 shell）里 \$$(PID) 不会改变？
因为 POSIX 规定：

> **在脚本中执行时，`$$` 必须保持脚本的 PID，不随 subshell 改变。**

bash 确实是这样实现的：

**✔ subshell 会改变进程 ID（PID）**

但

**❌ 在脚本内 `$$` 不会更新为新的 PID！**

也就是说：

- subshell（`()`）确实 fork 了一个新进程。
    
- 但 `$$` 是 shell 启动时设定的变量，在脚本中是固定值。
###### 🧪 用实验验证（真正的子进程 PID）
在 subshell 内打印真实 PID，需要用：

`echo "真实 pid: $(/bin/ps -o pid= -p $$)"`

或者更简单用：

`echo $BASHPID`

`$BASHPID` 是 bash 内部变量，会随 subshell 改变。

###### ✔ 例子
```bash

echo "父 shell BASHPID: $BASHPID"
(
    echo "子 shell BASHPID: $BASHPID"
)
父 shell BASHPID: 12345
子 shell BASHPID: 12346
```

###### 📌 如果在交互式 shell 执行呢？
在 interactive shell（命令行直接输入）中 `$$` **会随着 subshell 改变**：
```bash
$ echo $$
1000
$ (echo $$)
1001
```

##### 2.2.3.4.3 export 数组问题
Bash 到现在（5.x）为止都 _不支持_ 把数组真正 `export` 成环境变量
```bash
declare -a arr_parent=(a b c)
export arr_parent
bash -c 'echo "子Shell数组：${arr_parent[@]}"'
```
实际上：
- `export arr_parent` 只是把 **变量 `arr_parent` 的 _字符串值_** 放进环境里；
- 环境变量本质上就是一串 `name=value` 字符串，没有数组这种类型；
- 子 bash 进程拿到的是一个普通的标量变量，而不是数组。
这里的 `${arr_parent[@]}` 对一个标量来说，效果和 `$arr_parent` 一样，只是打印一串字符串，并没有真正的“数组元素”概念。
## 2.3 内置变量
Shell（Bash）中内置变量非常重要，它们由 Shell 自动提供，用于获取脚本信息、位置参数、进程信息、默认值处理等操作，提高脚本编写效率与可读性。
### 2.3.1 脚本相关变量（Script-related Variables）
脚本运行时 Bash 自动提供一些与脚本本身、参数、状态有关的变量。
#### 2.3.1.1 **📌 常见脚本相关内置变量表**

| 变量名         | 含义           | 示例          | 备注              |
| ----------- | ------------ | ----------- | --------------- |
| `$0`        | 当前脚本名称       | ./test.sh   | 可能包含路径          |
| `$1 ... $9` | 脚本的第 1–9 个参数 | $1 → 第一个参数  | 超过 9 需用 `${10}` |
| `$#`        | 参数个数         | `3`         | 常用于判断参数是否够      |
| `$@`        | 所有参数（独立处理）   | "a" "b" "c" | 逐个展开            |
| `$*`        | 所有参数（整体处理）   | "a b c"     | 与 `$@` 有区别      |
| `$$`        | 当前脚本进程 PID   | 28410       | 常用于生成唯一文件名      |
| `$!`        | 最近一次后台任务 PID | 1293        | 用于跟踪后台任务        |
| `$?`        | 上一条命令退出状态    | 0 / 非 0     | 判断命令是否成功        |
| `$_`        | 上条命令最后一个参数   | 很少用         | 也可用于命令历史        |
#### 2.3.1.2 **📘 示例：打印脚本相关变量**
```bash
17:22:38 root@redis01:~/note# cat test01.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test01.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
echo "脚本名称: $0"
echo "第一个参数: $1"
echo "参数个数: $#"
echo "所有参数(@): $@"
echo "所有参数(*): $*"
echo "当前 PID: $$"

ls /not/exist
echo "上一条命令退出状态: $?"

17:22:41 root@redis01:~/note# bash test01.sh
脚本名称: test01.sh
第一个参数: 
参数个数: 0
所有参数(@): 
所有参数(*): 
当前 PID: 6152
ls: cannot access '/not/exist': No such file or directory
上一条命令退出状态: 2
17:22:43 root@redis01:~/note#
```
#### 2.3.1.3 📊 `$@` 与 `$*` 的区别
`$@` 和 `$*` 都表示 Shell 脚本的 **全部位置参数**，但它们在 **被双引号包裹时的行为完全不同**。
他们的最大差异体现在：

> **`"$@"` 会将每个参数作为单独的独立字符串展开**  
> **`"$*"` 会把所有参数视为一个整体字符串展开**
##### 2.3.1.3.1 示意图
```lua
-- `"$@"` 展开示意图
+------------+ +-------------+ +------------+
|   "aa"     | |  "bb cc"    | |    "dd"    |
+------------+ +-------------+ +------------+
        ↑            ↑              ↑
   参数1（独立） 参数2（独立） 参数3（独立）
   
-- "$*" 展开示意图
+------------------------------------------+
|        "aa bb cc dd"                     |
+------------------------------------------+
                 ↑
         所有参数被合并成一个字符串
```

| 特性             | "$@"           | "$*"                     |
|------------------|----------------|---------------------------|
| 参数展开方式     | 逐个独立       | 合并成一个字符串         |
| 参数数量         | 保持原数量     | 变成 1 个                |
| 空格敏感性       | 保留每个参数的格式 | 空格会被合并         |
| 是否受 IFS 影响  | ❌ 不影响      | ✔ 由 IFS 连接            |
| 典型用途         | 传递参数给其他命令 | 拼接所有参数成一句话 |
| 是否推荐         | ✔ 强烈推荐     | ⚠ 不建议在脚本循环中     |
##### 2.3.1.3.2 代码示例
```bash
17:28:14 root@redis01:~/note# cat test02.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test02.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
echo '--- "$@" 展开 ---'
for arg in "$@"; do
    echo "[$arg]"
done

echo '--- "$*" 展开 ---'
for arg in "$*"; do
    echo "[$arg]"
done

17:28:15 root@redis01:~/note# bash test02.sh aa "bb cc" dd
--- "$@" 展开 ---
[aa]
[bb cc]
[dd]
--- "$*" 展开 ---
[aa bb cc dd]
```
##### 2.3.1.3.3 生产最佳实践
###### 🔥 **几乎所有情况下都推荐使用 `"$@"`**

原因：

- 保留参数边界
    
- 不会破坏包含空格的参数
    
- 与函数参数传递保持一致
    
- 脚本可移植性强
    

而：

###### ⚠ `"$*"` 在循环中几乎永远不该使用

因为它会把所有参数变成一个。
### 2.3.2 字符串相关
Bash 提供强大的字符串操作能力。
#### 2.3.2.1 📌 子串长度、截取、删除、替换等操作表
| 表达式                    | 功能         | 示例           | 结果            |
| ---------------------- | ---------- | ------------ | ------------- |
| `${#var}`              | 字符串长度      | var="hello"  | 5             |
| `${var:pos}`           | 从 pos 开始截取 | ${var:2}     | llo           |
| `${var:pos:len}`       | 截取指定长度     | ${var:1:3}   | ell           |
| `${var#pattern}`       | 从前匹配最短删除   | ${file#*/}   | 删除第一个 `/` 前内容 |
| `${var##pattern}`      | 从前匹配最长删除   | ${file##*/}  | 获取文件名         |
| `${var%pattern}`       | 从后匹配最短删除   | ${file%.*}   | 去掉后缀          |
| `${var%%pattern}`      | 从后匹配最长删除   | ${path%%/*}` | 获取第一个路径元素     |
| `${var/pattern/repl}`  | 替换首个匹配     | ${a/a/A}     | A bc          |
| `${var//pattern/repl}` | 替换全部匹配     | ${a//a/A}    | A bc A bc     |
#### 2.3.2.2 **📘 示例：常用字符串处理**
```bash
17:31:30 root@redis01:~/note# cat test03.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test03.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
name="linux_shell_study.txt"

echo ${#name}         # 字符串长度
echo ${name:0:5}      # 前 5 个字符
echo ${name%.txt}     # 删除后缀
echo ${name#*_}       # 删除第一个下划线前内容（shell_study.txt）
echo ${name//_/ }     # 替换所有下划线为空格

17:31:32 root@redis01:~/note# bash test03.sh
21
linux
linux_shell_study
shell_study.txt
linux shell study.txt
```

#### 2.3.2.3 📊 截取示意图（图解）
```pgsql
index 0 1 2 3 4 5 6 7 8 9 10
text  l i n u x _ s h e l l

${text:2:4}

l i n u x _ s h e l l
    |-------|
       ↑  ↑
       2  4 个字符
nux_       
       
```
### 2.3.3 默认值相关
用于给变量提供**默认值**、**赋值**、**报错**等功能。

---

#### 2.3.3.1 **📌 默认值、赋值、报错、替换等规则表**
| 表达式               | 含义                      | 示例                   | 行为说明    |
| ----------------- | ----------------------- | -------------------- | ------- |
| `${var:-default}` | var 未设置或为空，则使用 default  | `${name:-guest}`     | 不修改变量   |
| `${var:=default}` | var 未设置或为空，则赋值为 default | `${name:=guest}`     | 修改变量    |
| `${var:+alt}`     | var 已设置，则使用 alt，否则空     | `${name:+exists}`    | 常用于判断   |
| `${var:?message}` | var 为空或未设置则报错退出         | `${config:?未设置配置文件}` | 出错后脚本退出 |


#### 2.3.3.2 📘 示例：默认值、赋值、错误处理
```bash
17:37:29 root@redis01:~/note# cat test04.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: test04.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
echo "用户名: ${USER_NAME:-未指定}"
# 未赋值则不会改变变量本身

echo "设置用户: ${USER_NAME:=guest}"
# 如果之前为空，则 USER_NAME 现在变成 guest

echo "用户状态: ${USER_NAME:+已登记}"  # USER_NAME 非空 → 输出“已登记”

echo "配置文件位置: ${CONFIG_FILE:?必须提供 CONFIG_FILE}"
# 如果变量为空 → 脚本中断 + 打印错误

17:37:30 root@redis01:~/note# bash test04.sh
用户名: 未指定
设置用户: guest
用户状态: 已登记
test04.sh: line 18: CONFIG_FILE: 必须提供 CONFIG_FILE
```

#### 2.3.3.3 📊 默认值机制图解
```bash
${var:-default}
[ var ] → 空或未定义 → 使用 default 但不赋值


${var:=default}
[ var ] → 空或未定义 → 赋值为 default → var=default
```

# 三、脚本交互
## 3.1 基础知识
### 3.1.1 shell 登录解读
#### 3.1.1.1 shell 配置文件
Shell（以 Bash 为例）常见的配置文件如下：

|配置文件|作用|生效场景|
|---|---|---|
|`/etc/profile`|系统级初始化配置|登录 shell|
|`/etc/bashrc` 或 `/etc/bash.bashrc`|系统级 bash 配置|非登录 shell|
|`~/.bash_profile`|用户级登录配置（优先）|登录 shell|
|`~/.bash_login`|用户级登录配置（次优先）|登录 shell|
|`~/.profile`|用户级登录配置（最末）|登录 shell|
|`~/.bashrc`|交互式、非登录 shell 配置|终端打开 Bash 时|
常见内容

- 设置环境变量：`PATH`、`LANG` 等
- 设置别名：`alias ll='ls -l'`
- 设置提示符：`PS1`
- 加载函数、脚本等
📌 **小提示**：多数 Linux 默认在 `~/.bash_profile` 中再加载 `~/.bashrc`，确保登录/非登录行为一致。
🗂️ **常见 Shell 配置文件结构示意图**
![](assets/Shell%20编程/file-20251208221944908.png)

#### 3.1.1.2 shell 登录方式
##### 3.1.1.2.1 🔐 登录 shell（Login Shell）
![](assets/Shell%20编程/file-20251208222001111.png)
触发方式：

- SSH 登录
- 控制台登录（tty）
- `bash --login`
- `su - username`

会读取：
```bash
/etc/profile → ~/.bash_profile → ~/.bashrc
```

##### 3.1.1.2.2 🧩 非登录 shell（Not-login Shell）
触发方式：

- 图形界面打开终端（默认非登录）
- `su username`
- 在 shell 中执行 `bash`
- 运行脚本时的 Shell
```bash
/etc/bashrc → ~/.bashrc

```

#### 3.1.1.3 shell 配置文件生效顺序
```powershell
登录shell的文件生效流程

/etc/profile.d/*.sh

-> /etc/profile

-> /etc/bashrc

-> ~/.bashrc

-> ~/.bash_profile

非登录shell的文件生效流程

/etc/profile.d/*.sh

-> /etc/bashrc

-> ~/.bashrc

注意：

若多配置文件中设置相同的变量，则后面配置文件中变量的值会覆盖前面配置文件中同一变量的值。
```
#### 3.1.1.4 su 命令生效行为
```bash
su的相关参数

-：当前用户不仅切换为指定用户的身份，同时所用的工作环境也切换为此用户的环境。

-l：同 - 的使用类似，完整切换工作环境，后面需要添加欲切换的使用者账号。

-p：表示切换为指定用户的身份，但不改变当前的工作环境（不使用切换用户的配置文件）。

-m：和 -p 一样；

-c 命令：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令
```

|命令|类型|配置文件加载|
|---|---|---|
|`su user`|非登录 shell|加载 `~/.bashrc`|
|`su - user`|登录 shell|加载 `/etc/profile` + 用户全部登录文件|

示例说明：

- `su user`：保留原用户环境变量
    
- `su - user`：模拟完整登录环境
#### 3.1.1.5 配置文件如何生效
- **重新登录**
    
- 使用 `source` 或 `.`
    
    `source ~/.bashrc`
    
- 使用 `exec` 重启当前 shell
    
    `exec bash`
#### 3.1.1.6 配套代码示例
##### 3.1.1.6.1 非登录场景下环境差异实践
###### 3.1.1.6.1.1 Rocky Linux
```bash
[root rockylinux-1 ~] WORK 0 # echo "echo '1 - /etc/profile'" >> /etc/profile
echo "echo '2 - /etc/profile.d/2.sh'" >> /etc/profile.d/2.sh
echo "echo '3 - /etc/bashrc'" >> /etc/bashrc
echo "echo '4 - ~/.bash_profile'" >> ~/.bash_profile
echo "echo '5 - ~/.bashrc'" >> ~/.bashrc
[root rockylinux-1 ~] WORK 0 # su - test01
2 - /etc/profile.d/2.sh
3 - /etc/bashrc
1 - /etc/profile
3 - /etc/bashrc
[test01 rockylinux-1 ~] WORK 0 # su root
Password: 
2 - /etc/profile.d/2.sh
3 - /etc/bashrc
5 - ~/.bashrc
```
###### 3.1.1.6.1.2 Ubuntu Linux
```bash
[root rockylinux-1 ~] WORK 0 # echo "echo '1 - /etc/profile'" >> /etc/profile
echo "echo '2 - /etc/profile.d/2.sh'" >> /etc/profile.d/2.sh
echo "echo '3 - /etc/bashrc'" >> /etc/bashrc
echo "echo '4 - ~/.bash_profile'" >> ~/.bash_profile
echo "echo '5 - ~/.bashrc'" >> ~/.bashrc
13:18:19 root@redis01:~# su - test01
2 - /etc/profile.d/2.sh
1 - /etc/profile
test01@redis01:~$ su root
Password: 
2 - /etc/profile.d/2.sh
1 - /etc/profile
5 - ~/.bashrc
```
Login shell 加载顺序（Debian/Ubuntu 特性）
```ini
/etc/profile
   ↳ /etc/profile.d/*.sh
~/.bash_profile     (如果存在则只读它)
~/.profile          (如果没有 bash_profile 才读)
```
**不会自动加载：**

- `/etc/bashrc`（在 RHEL/CentOS 才有）
    
- `~/.bashrc`
## 3.2 脚本内外交互
### 3.2.1 read 基础
#### 3.2.1.1 基础知识
`read` 是 Shell 中用于**从标准输入读取用户输入**的命令，通常用于脚本与用户交互
`read [选项] 变量名`
常用选项说明：

| 选项   | 意义            |
| ---- | ------------- |
| `-p` | 指定提示信息        |
| `-t` | 限制等待输入的秒数（超时） |
| `-n` | 限制读取的字符数      |
| `-s` | 静默输入（常用于密码）   |
| `-r` | 读取原始输入，不解析反斜杠 |

默认情况下，`read` 从键盘读取一整行并存入变量。
#### 3.2.1.2 命令简单实践
##### 3.2.1.2.1 读取单个变量
```bash
15:08:59 root@redis01:~/shell/lesson02# cat demo01.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo01.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
read name

echo "Hello $name"

15:09:01 root@redis01:~/shell/lesson02# bash demo01.sh
aaaa
Hello aaaa
15:09:04 root@redis01:~/shell/lesson02# 
```
##### 3.2.1.2.2 读取多个变量
```bash
15:10:02 root@redis01:~/shell/lesson02# cat demo02.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo02.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
read a b c
echo "A=$a B=$b C=$c"

15:10:03 root@redis01:~/shell/lesson02# bash demo02.sh
1
A=1 B= C=
15:10:07 root@redis01:~/shell/lesson02# bash demo02.sh
1 2 3
A=1 B=2 C=3
```
#### 3.2.1.2.3 带提示符
```bash
15:13:25 root@redis01:~/shell/lesson02# cat demo03.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo03.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
read -rp "你的年龄是：" age
echo "你输入的年龄是 $age"

15:13:41 root@redis01:~/shell/lesson02# bash demo03.sh
你的年龄是：12
你输入的年龄是 12
15:13:46 root@redis01:~/shell/lesson02# bash demo03.sh
你的年龄是：1/2
你输入的年龄是 1/2
15:13:54 root@redis01:~/shell/lesson02# bash demo03.sh
你的年龄是：1\2
你输入的年龄是 1\2
15:13:58 root@redis01:~/shell/lesson02#
```
##### 3.2.1.2.4 静默读取密码
```bash
15:15:55 root@redis01:~/shell/lesson02# cat demo04.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo04.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
read -rsp "请输入密码: " pass
echo        # -s 会吞掉换行，手动补一个
echo "你的密码长度是 ${#pass} 位"

15:15:56 root@redis01:~/shell/lesson02# bash demo04.sh
请输入密码: 
你的密码长度是 3 位
15:16:00 root@redis01:~/shell/lesson02#
```
#### 3.2.1.3 信息提示
```bash
15:16:40 root@redis01:~/shell/lesson02# cat demo05.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo05.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
# 颜色函数
red(){ echo -e "\033[31m$*\033[0m"; }
green(){ echo -e "\033[32m$*\033[0m"; }

read -rp "$(green '>>> 请输入文件名: ')" file
[[ -f $file ]] && green "文件存在" || red "文件不存在"


15:16:45 root@redis01:~/shell/lesson02# bash demo05.sh
>>> 请输入文件名: aaa.sh
文件不存在
15:16:51 root@redis01:~/shell/lesson02#
```

#### 3.2.1.4 其他实践
##### 3.2.1.4.1 指定分隔符
```bash
15:17:52 root@redis01:~/shell/lesson02# cat demo06.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo06.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
IFS=, read -rp "请输入用逗号分隔的 学科-分数: " subject score
echo "学科=$subject, 分数=$score"

15:17:53 root@redis01:~/shell/lesson02# bash demo06.sh
请输入用逗号分隔的 学科-分数: Linux,88
学科=Linux, 分数=88
15:18:04 root@redis01:~/shell/lesson02#
```
##### 3.2.1.4.2 限时输入
```bash
15:18:45 root@redis01:~/shell/lesson02# cat demo07.sh
#!/bin/bash
# ==============================================================================
# 脚本基础信息
# filename: demo07.sh
# name: xuruizhao
# email: xuruizhao00@163.com
# v: LnxGuru
# GitHub: xuruizhao00-sys
# ==============================================================================
if read -t 3 -rp "3 秒内输入 YES: " ans && [[ $ans == YES ]]; then
    echo "快速通过！"
else
    echo "超时或输入错误！"
fi

15:18:47 root@redis01:~/shell/lesson02# bash demo07.sh
3 秒内输入 YES: yes
超时或输入错误！
15:18:55 root@redis01:~/shell/lesson02# bash demo07.sh
3 秒内输入 YES: YES
快速通过！
15:19:00 root@redis01:~/shell/lesson02# bash demo07.sh
3 秒内输入 YES: 超时或输入错误！
15:19:04 root@redis01:~/shell/lesson02#
```
### 3.2.2 案例
#### 3.2.2.1 登录模拟实验
```bash
USER_OK=admin
PASS_OK=123456

red(){  echo -e "\033[31m$*\033[0m"; }
green(){ echo -e "\033[32m$*\033[0m"; }

read -rp "账号: " user
read -rsp "密码: " pass
echo

[[ $user == "$USER_OK" && $pass == "$PASS_OK" ]] &&
    green "登录成功！" ||
    red "账号或密码错误！"
```
#### 3.2.2.2 堡垒机实践
